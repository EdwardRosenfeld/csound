vi:set nowrap:

The OSC opcodes found here have been implemented by Stefan Kersten
(steve@k-hornz.de) using Matt Wright's OSC-Kit library (you may find
the OSC-Kit library and documentation at
http://www.cnmat.berkeley.edu/OpenSoundControl).
These opcodes allow you to control a csound instrument from an OSC
client which may be sitting on the same machine or a different machine
connected over TCP/IP - the other machine should be running OSC
clients or servers (there are, for example, OSC objects available
in the Max environment).

In order to use the csound opcodes for OSC, you must:

1) pick up the OSC-Kit sources (at the URL above)

2) apply this very file into the OSC-Kit directory as a patch,
   like this:

   patch -p0 < README.OSC

3) alternatively to steps 1-2 you can access a CVS repository for the
   OSC-Kit like this:

   cvs -d ':pserver:anonymous@axdev.axnet.it:/home/nicb/projects/repositories' login
   Password:
   (the password is 'guest')
   cvs -d ':pserver:anonymous@axdev.axnet.it:/home/nicb/projects/repositories' OSC-Kit

   this will create an up-to-date OSC-Kit tree which does not require
   patching.

4) compile and install like this:

   make shared-lib
   make install (as root)

5) after this, you may want to run configure enabling the OSC opcodes:

   ./configure --enable-OSC-opcodes

There is no real documentation, now, for the use of the OSC opcodes.
But in doc/examples you may find a .csd file that helps to see how
the opcodes work. There is also a tcl script which implements some
simple sliders, and a shell script that runs together with the .csd
file to show you how you may send values to the opcodes with graphic
sliders. You can run them like this:

a) in one session, you can run:

   csound OSC-example.csd

b) in another session (or from another machine, indeed!), you can run:

   ./OSC-example.sh

As I said, all of this is the work of Matt Wright
(matt@cnmat.CNMAT.Berkeley.EDU) and of Stefan Kersten (steve@k-hornz.de).
I (nicb@axnet.it) just packaged the whole thing.

Enjoy

Nicola Bernardini

$Id$
------------------------------------------------------------------------
Index: .cvsignore
===================================================================
RCS file: .cvsignore
diff -N .cvsignore
--- /dev/null	Mon Jul 18 01:46:18 1994
+++ /tmp/cvs24954aaa	Fri Aug 11 10:34:40 2000
@@ -0,0 +1,2 @@
+simplesynth-osc
+libOSC.so.1.0
Index: Makefile
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/Makefile,v
retrieving revision 1.0.0.1
retrieving revision 1.4
diff -B -b -u -r1.0.0.1 -r1.4
--- Makefile	2000/04/23 08:17:59	1.0.0.1
+++ Makefile	2000/08/11 08:32:01	1.4
@@ -1,12 +1,30 @@
-CC = cc
-CFLAGS = -g -n32 
+#CC = cc
+#CFLAGS = -g -n32 
+#
+# settings for linux (uncomment when needed)
+#
+PREFIX=/usr/local
+INSTALL_LIBDIR=${PREFIX}/lib
+INSTALL_INCDIR=${PREFIX}/include/OSC
+CC=gcc
+INCLUDE=-I${PREFIX}/include
+DEBUG=#-DDEBUG
+DEFINE=-DLINUX $(DEBUG) -DHAS_NO_BSTRING_H
+CFLAGS=-g $(INCLUDE) $(DEFINE)
+VERSION_MAJOR=1
+VERSION_MINOR=1
+SHARED_LIB=libOSC.so
+SHARED_LIBSO=${SHARED_LIB}.${VERSION_MAJOR}.${VERSION_MINOR}
+LDCONFIG=/sbin/ldconfig
+INSTALL=install
+LN=ln
 
 OBJS = OSC-callbacklist.o OSC-receive.o \
 	OSC-timetag.o OSC-system-dependent.o OSC-string-help.o \
 	OSC-priority-queue.o OSC-drop.o OSC-address-space.o \
-	OSC-pattern-match.o NetworkReturnAddress.o
+	OSC-pattern-match.o NetworkReturnAddress.o OSC-client.o
 
-TESTPQ_OBJS = test-priority-queue.o OSC-priority-queue-heap.o \
+TESTPQ_OBJS = test-priority-queue.o OSC-priority-queue.o \
 	 OSC-system-dependent.o OSC-timetag.o
 
 simplesynth-osc: simplesynth-osc.o  ${OBJS}
@@ -19,10 +37,30 @@
 test: ${OBJS} testOSC.o
 	${CC} $(CFLAGS) -o $@ ${OBJS} testOSC.o
 
+#
+# this is a way to make shared libraries and to install them for
+# linux ELF - may be done differently on other platforms
+#
+shared-lib:		${SHARED_LIBSO}
+
+${SHARED_LIBSO}:	${OBJS}
+	${CC} -shared -Wl,-soname,${SHARED_LIB} -o $@ ${OBJS}
+
+install:		install-shared
+
+install-shared:		${SHARED_LIBSO}
+	${RM} ${INSTALL_LIBDIR}/${SHARED_LIB}
+	${INSTALL} -c ${SHARED_LIBSO} ${INSTALL_LIBDIR}
+	${LN} -s ${INSTALL_LIBDIR}/${SHARED_LIBSO} \
+		${INSTALL_LIBDIR}/${SHARED_LIB}
+	${INSTALL} -d ${INSTALL_INCDIR}
+	${INSTALL} -c -m 444 *.h ${INSTALL_INCDIR}
+	${LDCONFIG}
 
 tags: *.[c]
 	ctags *.[ch] > tags
 
 clean:
-	rm -f test test-pq *.o core
+	$(MAKE) -$(MAKEFLAGS) -C send+dump -f Makefile.linux $@
+	rm -f test test-pq *.o core ${SHARED_LIBSO}
 
Index: NetworkReturnAddress.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/NetworkReturnAddress.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- NetworkReturnAddress.c	2000/04/23 08:17:59	1.0.0.1
+++ NetworkReturnAddress.c	2000/04/24 15:16:52	1.1
@@ -52,7 +52,7 @@
     return sizeof(struct NetworkReturnAddressStruct);
 }
 
-Boolean NetworkSendReturnMessage(NetworkReturnAddressPtr addr,
+OSCBoolean NetworkSendReturnMessage(NetworkReturnAddressPtr addr,
 				 int n,
 				 void *buf) {
     if (addr == 0) return FALSE;
Index: NetworkReturnAddress.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/NetworkReturnAddress.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- NetworkReturnAddress.h	2000/04/23 08:18:00	1.0.0.1
+++ NetworkReturnAddress.h	2000/04/24 15:16:52	1.1
@@ -49,6 +49,6 @@
 int SizeOfNetworkReturnAddress(void);
 
 /* Send a packet back to the client, or do nothing if addr==0 */
-Boolean NetworkSendReturnMessage(NetworkReturnAddressPtr addr,
+OSCBoolean NetworkSendReturnMessage(NetworkReturnAddressPtr addr,
 				 int n,
 				 void *buf);
Index: NetworkUDP.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/NetworkUDP.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- NetworkUDP.h	2000/04/23 08:18:00	1.0.0.1
+++ NetworkUDP.h	2000/04/23 08:43:10	1.1
@@ -1,4 +1,4 @@
-#ifdef __sgi
+#if defined(__sgi) || defined(LINUX)
 #include <netinet/in.h>
 #endif
 
Index: OSC-address-space.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-address-space.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-address-space.c	2000/04/23 08:18:04	1.0.0.1
+++ OSC-address-space.c	2000/04/24 15:16:52	1.1
@@ -69,7 +69,7 @@
 };
 
 /* Globals */
-static Boolean Initialized = FALSE;
+static OSCBoolean Initialized = FALSE;
 static OSCcontainer OSCTopLevelContainer;
 static OSCcontainer freeContainers;   /* Linked list via next field. */
 static OSCMethod freeMethods;         /* Linked list via next field. */
@@ -223,7 +223,7 @@
 }
 
 
-Boolean OSCAddContainerAlias(OSCcontainer container, Name otherName) {
+OSCBoolean OSCAddContainerAlias(OSCcontainer container, Name otherName) {
     if (container->parent->numChildren >= MAX_CHILDREN_PER_CONTAINER) {
 	return FALSE;
     }
@@ -257,10 +257,10 @@
 
    
 
-Boolean OSCRemoveContainerAlias(OSCcontainer container, Name otherName) {
+OSCBoolean OSCRemoveContainerAlias(OSCcontainer container, Name otherName) {
     int i, j;
     OSCcontainer parent = container->parent;
-    Boolean found = FALSE;
+    OSCBoolean found = FALSE;
 
     for (i = 0; i < parent->numChildren; ++i) {
         if (parent->childrenNames[i] == otherName) {
@@ -329,7 +329,7 @@
 }
 
 
-Boolean OSCGetAddressString(char *target, int maxLength, OSCcontainer c) {
+OSCBoolean OSCGetAddressString(char *target, int maxLength, OSCcontainer c) {
     int lenNeeded;
 
     if (maxLength <= 1) return FALSE;
Index: OSC-address-space.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-address-space.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-address-space.h	2000/04/23 08:18:06	1.0.0.1
+++ OSC-address-space.h	2000/04/24 15:16:52	1.1
@@ -181,13 +181,13 @@
 
 /* Given a pointer to a container, and another name for that container, add or
    remove that name as an alias for the container.  Return FALSE for failure. */
-Boolean OSCAddContainerAlias(OSCcontainer container, Name otherName);
-Boolean OSCRemoveContainerAlias(OSCcontainer container, Name otherName);
+OSCBoolean OSCAddContainerAlias(OSCcontainer container, Name otherName);
+OSCBoolean OSCRemoveContainerAlias(OSCcontainer container, Name otherName);
 
 
 /* Write the OSC address of the given container into the given string.
    Return FALSE if the address won't fit in the string. */
-Boolean OSCGetAddressString(char *target, int maxLength, OSCcontainer c);
+OSCBoolean OSCGetAddressString(char *target, int maxLength, OSCcontainer c);
 
 
 /* Given an address (not a pattern!), return the single OSCcontainer it names,
Index: OSC-callbacklist.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-callbacklist.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-callbacklist.c	2000/04/23 08:18:07	1.0.0.1
+++ OSC-callbacklist.c	2000/04/24 15:16:52	1.1
@@ -51,7 +51,7 @@
 static callbackList freeNodes;
 
 /* Call this before you call anything else */
-Boolean InitCallbackListNodes(int numNodes, void *(*InitTimeMalloc)(int numBytes)) {
+OSCBoolean InitCallbackListNodes(int numNodes, void *(*InitTimeMalloc)(int numBytes)) {
     int i;
 
     allNodes = (*InitTimeMalloc)(numNodes * sizeof(*allNodes));
Index: OSC-callbacklist.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-callbacklist.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-callbacklist.h	2000/04/23 08:18:07	1.0.0.1
+++ OSC-callbacklist.h	2000/04/24 15:16:52	1.1
@@ -41,7 +41,7 @@
 
 
 /* Call this before you call anything else. */
-Boolean InitCallbackListNodes(int numNodes, void *(*InitTimeMalloc)(int numBytes));
+OSCBoolean InitCallbackListNodes(int numNodes, void *(*InitTimeMalloc)(int numBytes));
 
 callbackList AllocCallbackListNode(methodCallback callback, void *context, 
 				   struct callbackListNode *next);
Index: OSC-client.c
===================================================================
RCS file: OSC-client.c
diff -N OSC-client.c
--- /dev/null	Mon Jul 18 01:46:18 1994
+++ OSC-client.c	Fri Aug 11 10:34:40 2000
@@ -0,0 +1,303 @@
+/*
+Copyright (c) 1996.  The Regents of the University of California (Regents).
+All Rights Reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for educational, research, and not-for-profit purposes, without
+fee and without a signed licensing agreement, is hereby granted, provided that
+the above copyright notice, this paragraph and the following two paragraphs
+appear in all copies, modifications, and distributions.  Contact The Office of
+Technology Licensing, UC Berkeley, 2150 Shattuck Avenue, Suite 510, Berkeley,
+CA 94720-1620, (510) 643-7201, for commercial licensing opportunities.
+
+Written by Matt Wright, The Center for New Music and Audio Technologies,
+University of California, Berkeley.
+
+     IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
+     ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+     REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
+     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".
+     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
+     ENHANCEMENTS, OR MODIFICATIONS.
+*/
+
+
+/* 
+  Author: Matt Wright
+  Version 2.1
+ */
+
+
+/* Here are the possible values of the state field: */
+
+#define EMPTY 0	       /* Nothing written to packet yet */
+#define ONE_MSG_ARGS 1 /* Packet has a single message; gathering arguments */
+#define NEED_COUNT 2   /* Just opened a bundle; must write message name or
+			  open another bundle */
+#define GET_ARGS 3     /* Getting arguments to a message.  If we see a message
+			  name or a bundle open/close then the current message
+			  will end. */
+#define DONE 4         /* All open bundles have been closed, so can't write 
+		          anything else */
+
+#include "OSC-client.h"
+
+char *OSC_errorMessage;
+
+
+static int strlen(char *s);
+static int OSC_padString(char *dest, char *str);
+
+void OSC_initBuffer(OSCbuf *buf, int size, char *byteArray) {
+    buf->buffer = byteArray;
+    buf->size = size;
+    OSC_resetBuffer(buf);
+}
+
+void OSC_resetBuffer(OSCbuf *buf) {	
+    buf->bufptr = buf->buffer;
+    buf->state = EMPTY;
+    buf->bundleDepth = 0;
+    buf->prevCounts[0] = 0;
+}
+
+int OSC_isBufferEmpty(OSCbuf *buf) {
+    return buf->bufptr == buf->buffer;
+}
+
+int OSC_freeSpaceInBuffer(OSCbuf *buf) {
+    return buf->size - (buf->bufptr - buf->buffer);
+}
+
+int OSC_isBufferDone(OSCbuf *buf) {
+    return (buf->state == DONE || buf->state == ONE_MSG_ARGS);
+}
+
+char *OSC_getPacket(OSCbuf *buf) {
+#ifdef ERROR_CHECK_GETPACKET
+    if (buf->state == DONE || buf->state == ONE_MSG_ARGS) {
+	return buf->buffer;
+    } else {
+	OSC_errorMessage = "Packet has unterminated bundles";
+	return 0;
+    }
+#else
+    return buf->buffer;
+#endif
+}
+
+int OSC_packetSize(OSCbuf *buf) {
+#ifdef ERROR_CHECK_PACKETSIZE
+    if (buf->state == DONE || buf->state == ONE_MSG_ARGS) {
+	return (buf->bufptr - buf->buffer);
+    } else {
+        OSC_errorMessage = "Packet has unterminated bundles";
+        return 0;
+    }
+#else
+    return (buf->bufptr - buf->buffer);
+#endif
+}
+
+#define CheckOverflow(buf, bytesNeeded) { \
+    if ((bytesNeeded) > OSC_freeSpaceInBuffer(buf)) { \
+	OSC_errorMessage = "buffer overflow"; \
+	return 1; \
+    } \
+}
+
+static void PatchMessageSize(OSCbuf *buf) {
+    int4byte size;
+    size = buf->bufptr - ((char *) buf->thisMsgSize) - 4;
+    *(buf->thisMsgSize) = size;
+}
+
+int OSC_openBundle(OSCbuf *buf, OSCTimeTag tt) {
+    if (buf->state == ONE_MSG_ARGS) {
+	OSC_errorMessage = "Can't open a bundle in a one-message packet";
+	return 3;
+    }
+
+    if (buf->state == DONE) {
+	OSC_errorMessage = "This packet is finished; can't open a new bundle";
+	return 4;
+    }
+
+    if (++(buf->bundleDepth) >= MAX_BUNDLE_NESTING) {
+	OSC_errorMessage = "Bundles nested too deeply; change MAX_BUNDLE_NESTING in OpenSoundControl.h";
+	return 2;
+    }
+
+    if (buf->state == GET_ARGS) {
+	PatchMessageSize(buf);
+    }
+
+    if (buf->state == EMPTY) {
+	/* Need 16 bytes for "#bundle" and time tag */
+	CheckOverflow(buf, 16);
+    } else {
+	/* This bundle is inside another bundle, so we need to leave
+	   a blank size count for the size of this current bundle. */
+	CheckOverflow(buf, 20);
+	*((int4byte *)buf->bufptr) = 0xaaaaaaaa;
+        buf->prevCounts[buf->bundleDepth] = (int4byte *)buf->bufptr;
+
+	buf->bufptr += 4;
+    }
+
+    buf->bufptr += OSC_padString(buf->bufptr, "#bundle");
+    *((OSCTimeTag *) buf->bufptr) = tt;
+    buf->bufptr += sizeof(OSCTimeTag);
+
+    buf->state = NEED_COUNT;
+    return 0;
+}
+
+
+int OSC_closeBundle(OSCbuf *buf) {
+    if (buf->bundleDepth == 0) {
+	/* This handles EMPTY, ONE_MSG, ARGS, and DONE */
+	OSC_errorMessage = "Can't close bundle; no bundle is open!";
+	return 5;
+    }
+
+    if (buf->state == GET_ARGS) {
+        PatchMessageSize(buf);
+    }
+
+    if (buf->bundleDepth == 1) {
+	/* Closing the last bundle: No bundle size to patch */
+	buf->state = DONE;
+    } else {
+	/* Closing a sub-bundle: patch bundle size */
+	int size = buf->bufptr - ((char *) buf->prevCounts[buf->bundleDepth]) - 4;
+	*(buf->prevCounts[buf->bundleDepth]) = size;
+	buf->state = NEED_COUNT;
+    }
+
+    --buf->bundleDepth;
+    return 0;
+}
+	
+
+int OSC_closeAllBundles(OSCbuf *buf) {
+    if (buf->bundleDepth == 0) {
+        /* This handles EMPTY, ONE_MSG, ARGS, and DONE */
+        OSC_errorMessage = "Can't close all bundles; no bundle is open!";
+        return 6;
+    }
+
+    while (buf->bundleDepth > 0) {
+	OSC_closeBundle(buf);
+    }
+    return 0;
+}
+
+int OSC_writeAddress(OSCbuf *buf, char *name) {
+    int4byte paddedLength;
+
+    if (buf->state == ONE_MSG_ARGS) {
+	OSC_errorMessage = "This packet is not a bundle, so you can't write another address";
+	return 7;
+    }
+
+    if (buf->state == DONE) {
+        OSC_errorMessage = "This packet is finished; can't write another address";
+        return 8;
+    }
+
+    paddedLength = OSC_effectiveStringLength(name);
+
+    if (buf->state == EMPTY) {
+	/* This will be a one-message packet, so no sizes to worry about */
+	CheckOverflow(buf, paddedLength);
+	buf->state = ONE_MSG_ARGS;
+    } else {
+	/* GET_ARGS or NEED_COUNT */
+	CheckOverflow(buf, 4+paddedLength);
+	if (buf->state == GET_ARGS) {
+	    /* Close the old message */
+	    PatchMessageSize(buf);
+	}
+	buf->thisMsgSize = (int4byte *)buf->bufptr;
+	*(buf->thisMsgSize) = 0xbbbbbbbb;
+	buf->bufptr += 4;
+	buf->state = GET_ARGS;
+    }
+
+    /* Now write the name */
+    buf->bufptr += OSC_padString(buf->bufptr, name);
+    return 0;
+}
+
+int OSC_writeFloatArg(OSCbuf *buf, float arg) {
+    CheckOverflow(buf, 4);
+    *((float *) buf->bufptr) = arg;
+    buf->bufptr += 4;
+    return 0;
+}
+
+int OSC_writeFloatArgs(OSCbuf *buf, int numFloats, float *args) {
+    int i;
+    CheckOverflow(buf, 4 * numFloats);
+    for (i = 0; i < numFloats; i++) {
+	*((float *) buf->bufptr) = args[i];
+	buf->bufptr += 4;
+    }
+    return 0;
+}
+
+int OSC_writeIntArg(OSCbuf *buf, int4byte arg) {
+    CheckOverflow(buf, 4);
+    *((int4byte *) buf->bufptr) = arg;
+    buf->bufptr += 4;
+    return 0;
+}
+
+int OSC_writeStringArg(OSCbuf *buf, char *arg) {
+    CheckOverflow(buf, OSC_effectiveStringLength(arg));
+    buf->bufptr += OSC_padString(buf->bufptr, arg);
+    return 0;
+}
+
+/* String utilities */
+
+static int strlen(char *s) {
+    int i;
+    for (i=0; s[i] != '\0'; i++) /* Do nothing */ ;
+    return i;
+}
+
+#define STRING_ALIGN_PAD 4
+int OSC_effectiveStringLength(char *string) {
+    int len = strlen(string) + 1;  /* We need space for the null char. */
+    
+    /* Round up len to next multiple of STRING_ALIGN_PAD to account for alignment padding */
+    if ((len % STRING_ALIGN_PAD) != 0) {
+        len += STRING_ALIGN_PAD - (len % STRING_ALIGN_PAD);
+    }
+    return len;
+}
+
+static int OSC_padString(char *dest, char *str) {
+    int i;
+    
+    for (i = 0; str[i] != '\0'; i++) {
+        dest[i] = str[i];
+    }
+    
+    dest[i] = '\0';
+    i++;
+    
+    for (; (i % STRING_ALIGN_PAD) != 0; i++) {
+        dest[i] = '\0';
+    }
+    
+    return i;
+}
+ 
Index: OSC-client.h
===================================================================
RCS file: OSC-client.h
diff -N OSC-client.h
--- /dev/null	Mon Jul 18 01:46:18 1994
+++ /tmp/cvs24954raa	Fri Aug 11 10:34:40 2000
@@ -0,0 +1,182 @@
+/*
+Copyright (c) 1996,1997.  The Regents of the University of California (Regents).
+All Rights Reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for educational, research, and not-for-profit purposes, without
+fee and without a signed licensing agreement, is hereby granted, provided that
+the above copyright notice, this paragraph and the following two paragraphs
+appear in all copies, modifications, and distributions.  Contact The Office of
+Technology Licensing, UC Berkeley, 2150 Shattuck Avenue, Suite 510, Berkeley,
+CA 94720-1620, (510) 643-7201, for commercial licensing opportunities.
+
+Written by Matt Wright, The Center for New Music and Audio Technologies,
+University of California, Berkeley.
+
+     IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
+     ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+     REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
+     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".
+     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
+     ENHANCEMENTS, OR MODIFICATIONS.
+*/
+
+/* 
+
+   OSC-client.h: library for constructing OpenSoundControl messages.
+   Derived from SynthControl.h
+   Author: Matt Wright
+   Version 0.1: 6/13/97
+
+
+   General notes:
+
+   This library abstracts away the data format for the OpenSoundControl
+   protocol.  Users of this library can construct OpenSoundControl packets
+   with a function call interface instead of knowing how to lay out the bits.
+
+   All issues of memory allocation are deferred to the user of this library.
+   There are two data structures that the user must allocate.  The first
+   is the actual buffer that the message will be written into.  This buffer
+   can be any size, but if it's too small there's a possibility that it
+   will become overfull.  The other data structure is called an OSCbuf,
+   and it holds all the state used by the library as it's constructing
+   a buffer.
+
+   All procedures that have the possibility of an error condition return int,
+   with 0 indicating no error and nonzero indicating an error.  The variable
+   OSC_errorMessage will be set to point to a string containing an error
+   message explaining what the problem is.
+
+*/
+
+#if !defined(_OSC_OSC_CLIENT_h_)
+#	define _OSC_OSC_CLIENT_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "OSC-timetag.h"
+
+/* The int4byte type has to be a 4-byte integer.  You may have to
+   change this to long or something else on your system.  */
+#ifdef __MWERKS__
+  /* In Metrowerks you can set ints to be 2 or 4 bytes on 68K, but long is
+     always 4 bytes */
+    typedef long int4byte;
+#else
+    typedef int int4byte;
+#endif
+
+/* The maximum depth of bundles within bundles within bundles within...
+   This is the size of a static array.  If you exceed this limit you'll 
+   get an error message. */
+#define MAX_BUNDLE_NESTING 32
+
+
+/* Don't ever manipulate the data in the OSCbuf struct directly.  (It's
+   declared here in the header file only so your program will be able to
+   declare variables of type OSCbuf and have the right amount of memory
+   be allocated.) */
+
+typedef struct OSCbuf_struct {
+    char *buffer;            /* The buffer to hold the OSC packet */
+    int size;                /* Size of the buffer */
+    char *bufptr;            /* Current position as we fill the buffer */
+    int state;		     /* State of half-constructed message */
+    int4byte *thisMsgSize;   /* Pointer to count field before 
+			        currently-being-written message */
+    int4byte *prevCounts[MAX_BUNDLE_NESTING];
+			     /* Pointers to count field before each currently
+			        open bundle */
+    int bundleDepth;	     /* How many sub-sub-bundles are we in now? */
+} OSCbuf;
+
+
+/* Initialize the given OSCbuf.  The user of this module must pass in the
+   block of memory that this OSCbuf will use for a buffer, and the number of
+   bytes in that block.  (It's the user's job to allocate the memory because
+   you do it differently in different systems.) */
+void OSC_initBuffer(OSCbuf *buf, int size, char *byteArray);
+
+
+/* Reset the given OSCbuf.  Do this after you send out the contents of
+   the buffer and want to start writing new data into it. */
+void OSC_resetBuffer(OSCbuf *buf);
+
+
+/* Is the buffer empty?  (I.e., would it be stupid to send the buffer
+   contents to the synth?) */
+int OSC_isBufferEmpty(OSCbuf *buf);
+
+
+/* How much space is left in the buffer? */
+int OSC_freeSpaceInBuffer(OSCbuf *buf);
+
+/* Does the buffer contain a valid OSC packet?  (Returns nonzero if yes.) */
+int OSC_isBufferDone(OSCbuf *buf);
+
+/* When you're ready to send out the buffer (i.e., when OSC_isBufferDone()
+   returns true), call these two procedures to get the OSC packet that's been
+   assembled and its size in bytes.  (And then call OSC_resetBuffer() if you
+   want to re-use this OSCbuf for the next packet.)  */
+char *OSC_getPacket(OSCbuf *buf);
+int OSC_packetSize(OSCbuf *buf);
+
+
+
+/* Here's the basic model for building up OSC messages in an OSCbuf:
+
+    - Make sure the OSCbuf has been initialized with OSC_initBuffer().
+
+    - To open a bundle, call OSC_openBundle().  You can then write 
+      messages or open new bundles within the bundle you opened.
+      Call OSC_closeBundle() to close the bundle.  Note that a packet
+      does not have to have a bundle; it can instead consist of just a 
+      single message.
+								  
+
+    - For each message you want to send:
+
+	- Call OSC_writeAddress() with the name of your message.  (In
+	  addition to writing your message name into the buffer, this
+	  procedure will also leave space for the size count of this message.)
+	
+	- Now write each of the arguments into the buffer, by calling one of:
+	    OSC_writeFloatArg()
+	    OSC_writeFloatArgs()
+	    OSC_writeIntArg()
+	    OSC_writeStringArg()
+
+	- Now your message is complete; you can send out the buffer or you can
+	  add another message to it.
+*/
+
+int OSC_openBundle(OSCbuf *buf, OSCTimeTag tt);
+int OSC_closeBundle(OSCbuf *buf);
+int OSC_closeAllBundles(OSCbuf *buf);
+
+int OSC_writeAddress(OSCbuf *buf, char *name);
+int OSC_writeFloatArg(OSCbuf *buf, float arg);
+int OSC_writeFloatArgs(OSCbuf *buf, int numFloats, float *args);
+int OSC_writeIntArg(OSCbuf *buf, int4byte arg);
+int OSC_writeStringArg(OSCbuf *buf, char *arg);
+
+extern char *OSC_errorMessage;
+
+/* How many bytes will be needed in the OSC format to hold the given
+   string?  The length of the string, plus the null char, plus any padding
+   needed for 4-byte alignment. */ 
+int OSC_effectiveStringLength(char *string);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* !defined(_OSC_OSC_CLIENT_h_) */
Index: OSC-common.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-common.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-common.h	2000/04/23 08:18:07	1.0.0.1
+++ OSC-common.h	2000/04/24 15:16:52	1.1
@@ -38,12 +38,18 @@
 
 /* Boolean type */
 
-#ifndef TRUE
-typedef int Boolean;
-#define TRUE 1
-#define FALSE 0
-#endif
+#if defined(TRUE)
+#       undef TRUE              /* otherwise we will lose some typedefing */
+#endif  /* defined(TRUE) */
+#if defined(FALSE)
+#       undef FALSE             /* same as above */
+#endif /* defined(FALSE) */
 
+typedef enum
+{
+    FALSE = 0,
+    TRUE  = 1
+} OSCBoolean;
 
 /* Fixed byte width types */
 typedef int int4;   /* 4 byte int */
Index: OSC-internal-messages.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-internal-messages.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-internal-messages.h	2000/04/23 08:18:07	1.0.0.1
+++ OSC-internal-messages.h	2000/04/24 15:16:52	1.1
@@ -44,11 +44,11 @@
    returns after the message has been sent (or has failed to be sent),
    so the memory for address and args can be on the stack.  Returns FALSE
    if there's a problem; TRUE otherwise. */
-Boolean OSCSendInternalMessage(char *address, int arglen, void *args);
+OSCBoolean OSCSendInternalMessage(char *address, int arglen, void *args);
 
 
 /* Same thing, but with a return address supplied. */
-Boolean OSCSendInternalMessageWithRSVP(char *address, int arglen,  void *args, 
+OSCBoolean OSCSendInternalMessageWithRSVP(char *address, int arglen,  void *args, 
 				       NetworkReturnAddressPtr returnAddr);
 
 
@@ -67,6 +67,6 @@
    return address for later use.
 */
 
-Boolean OSCScheduleInternalMessages(OSCTimeTag when, int numMessages, 
+OSCBoolean OSCScheduleInternalMessages(OSCTimeTag when, int numMessages, 
 				    char **addresses, int *arglens,
 				    void **args);
Index: OSC-pattern-match.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-pattern-match.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-pattern-match.c	2000/04/23 08:18:08	1.0.0.1
+++ OSC-pattern-match.c	2000/04/24 15:16:52	1.1
@@ -41,10 +41,10 @@
 
 static const char *theWholePattern;	/* Just for warning messages */
 
-static Boolean MatchBrackets (const char *pattern, const char *test);
-static Boolean MatchList (const char *pattern, const char *test);
+static OSCBoolean MatchBrackets (const char *pattern, const char *test);
+static OSCBoolean MatchList (const char *pattern, const char *test);
 
-Boolean PatternMatch (const char *  pattern, const char * test) {
+OSCBoolean PatternMatch (const char *  pattern, const char * test) {
   theWholePattern = pattern;
   
   if (pattern == 0 || pattern[0] == 0) {
@@ -95,9 +95,9 @@
 
 /* we know that pattern[0] == '[' and test[0] != 0 */
 
-static Boolean MatchBrackets (const char *pattern, const char *test) {
-  Boolean result;
-  Boolean negated = FALSE;
+static OSCBoolean MatchBrackets (const char *pattern, const char *test) {
+  OSCBoolean result;
+  OSCBoolean negated = FALSE;
   const char *p = pattern;
 
   if (pattern[1] == 0) {
@@ -146,7 +146,7 @@
   return PatternMatch (p+1,test+1);
 }
 
-static Boolean MatchList (const char *pattern, const char *test) {
+static OSCBoolean MatchList (const char *pattern, const char *test) {
 
  const char *restOfPattern, *tp = test;
 
Index: OSC-pattern-match.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-pattern-match.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-pattern-match.h	2000/04/23 08:18:08	1.0.0.1
+++ OSC-pattern-match.h	2000/04/24 15:16:52	1.1
@@ -33,5 +33,5 @@
     OSC-pattern-match.h
 */
 
-Boolean PatternMatch (const char *pattern, const char *test);
+OSCBoolean PatternMatch (const char *pattern, const char *test);
 
Index: OSC-priority-queue.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-priority-queue.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-priority-queue.c	2000/04/23 08:18:08	1.0.0.1
+++ OSC-priority-queue.c	2000/04/24 15:16:52	1.1
@@ -80,7 +80,7 @@
     return result;
 }
 
-OSCQueueInsert(OSCQueue q, OSCSchedulableObject new) {
+OSCBoolean OSCQueueInsert(OSCQueue q, OSCSchedulableObject new) {
     if (q->n == CAPACITY) return FALSE;
 
     q->list[q->n] = new;
Index: OSC-priority-queue.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-priority-queue.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-priority-queue.h	2000/04/23 08:18:08	1.0.0.1
+++ OSC-priority-queue.h	2000/04/24 15:16:52	1.1
@@ -53,7 +53,7 @@
 OSCQueue OSCNewQueue(int maxItems, void *(*InitTimeMalloc)(int numBytes));
 
 /* Put something into the queue.  Return FALSE if quque is full. */
-Boolean OSCQueueInsert(OSCQueue q, OSCSchedulableObject o);
+OSCBoolean OSCQueueInsert(OSCQueue q, OSCSchedulableObject o);
 
 /* What's the time tag of the earliest item in the queue? 
    Return OSCTT_BiggestPossibleTimeTag() if queue is empty. */
Index: OSC-receive.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-receive.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-receive.c	2000/04/23 08:18:12	1.0.0.1
+++ OSC-receive.c	2000/04/24 15:16:52	1.1
@@ -56,7 +56,7 @@
 struct {
     OSCQueue TheQueue;		/* The Priority Queue */
     OSCTimeTag lastTimeTag;	/* Best approximation to current time */
-    Boolean timePassed;		/* TRUE if OSCInvokeMessagesThatAreReady() has been
+    OSCBoolean timePassed;		/* TRUE if OSCInvokeMessagesThatAreReady() has been
 				   called since the last time OSCBeProductiveWhileWaiting() was. */
     int recvBufSize;		/* Size of all receive buffers */
     void *(*InitTimeMalloc)(int numBytes);
@@ -72,7 +72,7 @@
     int refcount;		/* # queued things using memory from this buffer */
     struct OSCPacketBuffer_struct *nextFree;	/* For linked list of free packets */
 
-    Boolean returnAddrOK;       /* Because returnAddr points to memory we need to
+    OSCBoolean returnAddrOK;       /* Because returnAddr points to memory we need to
 				   store future return addresses, we set this
 				   field to FALSE in situations where a packet
 				   buffer "has no return address" instead of
@@ -119,14 +119,14 @@
 
 
 /* Static procedure declatations */
-static Boolean InitPackets(int receiveBufferSize, int clientAddrSize, int numReceiveBuffers);
-static Boolean InitQueuedData(int numQueuedObjects);
+static OSCBoolean InitPackets(int receiveBufferSize, int clientAddrSize, int numReceiveBuffers);
+static OSCBoolean InitQueuedData(int numQueuedObjects);
 static queuedData *AllocQD(void);
 static void FreeQD(queuedData *qd);
 static void CallWholeCallbackList(callbackList l, int argLength, void *args, OSCTimeTag when, NetworkReturnAddressPtr returnAddr);
 static void InsertBundleOrMessage(char *buf, int n, OSCPacketBuffer packet, OSCTimeTag enclosingTimeTag);
 static void ParseBundle(queuedData *qd);
-static Boolean ParseMessage(queuedData *qd);
+static OSCBoolean ParseMessage(queuedData *qd);
 /* static void CheckPacketRefcount(OSCPacketBuffer packet); */
 static void PacketAddRef(OSCPacketBuffer packet);
 static void PacketRemoveRef(OSCPacketBuffer packet);
@@ -137,7 +137,7 @@
  **************************************************/
 
 
-Boolean OSCInitReceive(struct OSCReceiveMemoryTuner *t) {
+OSCBoolean OSCInitReceive(struct OSCReceiveMemoryTuner *t) {
     globals.recvBufSize = t->receiveBufferSize;
     globals.InitTimeMalloc = t->InitTimeMemoryAllocator;
     globals.RealTimeMemoryAllocator = t->RealTimeMemoryAllocator;
@@ -180,7 +180,7 @@
 
 #define MIN_REASONABLE_RCV_BUFSIZE 128
 
-static Boolean InitPackets(int receiveBufferSize, int clientAddrSize, int numReceiveBuffers) {
+static OSCBoolean InitPackets(int receiveBufferSize, int clientAddrSize, int numReceiveBuffers) {
     int i;
     struct OSCPacketBuffer_struct *allPackets;
 
@@ -291,7 +291,7 @@
 }
 #endif
 
-static Boolean InitQueuedData(int numQueuedObjects) {
+static OSCBoolean InitQueuedData(int numQueuedObjects) {
     int i;
     queuedData *allQD;
 
@@ -355,7 +355,7 @@
     OSCInvokeAllMessagesThatAreReady(globals.lastTimeTag);
 }
 
-Boolean OSCBeProductiveWhileWaiting(void) {
+OSCBoolean OSCBeProductiveWhileWaiting(void) {
     /* Here's where we could be clever if an allocation fails. 
        (I.e., if we're out of QD objects, we should avoid
        parsing bundles.) The code isn't that smart yet. */
@@ -393,7 +393,7 @@
     }
 }
     
-Boolean OSCInvokeMessagesThatAreReady(OSCTimeTag now) {
+OSCBoolean OSCInvokeMessagesThatAreReady(OSCTimeTag now) {
     queuedData *x;
     OSCTimeTag thisTimeTag;
 
@@ -489,7 +489,7 @@
 }
 
 static void InsertBundleOrMessage(char *buf, int n, OSCPacketBuffer packet, OSCTimeTag enclosingTimeTag) {
-    Boolean IsBundle;
+    OSCBoolean IsBundle;
     queuedData *qd;
 
     /* We add the reference first thing so in case any of the upcoming
@@ -607,7 +607,7 @@
 }
 
 
-static Boolean ParseMessage(queuedData *qd) {
+static OSCBoolean ParseMessage(queuedData *qd) {
     /* Fill in all the information we'll need to execute the message as
        quickly as possible when the time comes.  This means figuring out where
        the address ends and the arguments begin, and also pattern matching the
@@ -672,11 +672,11 @@
 
 #include "OSC-internal-messages.h"
 
-Boolean OSCSendInternalMessage(char *address, int arglen, void *args) {
+OSCBoolean OSCSendInternalMessage(char *address, int arglen, void *args) {
     return OSCSendInternalMessageWithRSVP(address, arglen, args, 0);
 }
 
-Boolean OSCSendInternalMessageWithRSVP(char *address, int arglen, void *args,
+OSCBoolean OSCSendInternalMessageWithRSVP(char *address, int arglen, void *args,
 				       NetworkReturnAddressPtr returnAddr) {
     callbackList l = OSCDispatchMessage(address);
 
@@ -688,7 +688,7 @@
 
 
 
-Boolean OSCScheduleInternalMessages(OSCTimeTag when, int numMessages, 
+OSCBoolean OSCScheduleInternalMessages(OSCTimeTag when, int numMessages, 
 				    char **addresses, int *arglens, void **args) {
     int i, bufSizeNeeded, paddedStrLen;
     OSCPacketBuffer p;
Index: OSC-receive.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-receive.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-receive.h	2000/04/23 08:18:13	1.0.0.1
+++ OSC-receive.h	2000/04/24 15:16:52	1.1
@@ -110,7 +110,7 @@
 int OSCReceiveMemoryThatWouldBeAllocated(struct OSCReceiveMemoryTuner *t);
 
 /* Returns FALSE if it fails to initialize */
-Boolean OSCInitReceive(struct OSCReceiveMemoryTuner *t);
+OSCBoolean OSCInitReceive(struct OSCReceiveMemoryTuner *t);
 
 /**************************************************
    Managing packet data structures
@@ -182,7 +182,7 @@
    it does only a small unit of this kind of work.  If it
    returns TRUE and you still have time before the next thing
    you have to do, call it again.) */
-Boolean OSCBeProductiveWhileWaiting(void);
+OSCBoolean OSCBeProductiveWhileWaiting(void);
 
 /* Call this whenever enough time has passed that you want to see which
    messages are now ready and have them take effect.  (For example, in a
@@ -196,7 +196,7 @@
    tag, this procedure does not invoke them, but returns TRUE to indicate
    that more messages are ready.
 */
-Boolean OSCInvokeMessagesThatAreReady(OSCTimeTag now);
+OSCBoolean OSCInvokeMessagesThatAreReady(OSCTimeTag now);
 
 /* Same thing, but invokes all of the messages whose time has come. */
 void OSCInvokeAllMessagesThatAreReady(OSCTimeTag now);
Index: OSC-string-help.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-string-help.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-string-help.c	2000/04/23 08:18:14	1.0.0.1
+++ OSC-string-help.c	2000/04/24 15:16:52	1.1
@@ -36,7 +36,7 @@
    by Matt Wright, 3/19/98
 */
 
-#include "OSC-common.h"  /* For Boolean */
+#include "OSC-common.h"  /* For OSCBoolean */
 
 #define STRING_ALIGN_PAD 4
 
@@ -100,7 +100,7 @@
     return target;
 }
 
-Boolean OSCParseStringList(const char *result[], int *numStrings, int maxStrings,
+OSCBoolean OSCParseStringList(const char *result[], int *numStrings, int maxStrings,
 			   const char *args, int numBytes) {
     int numFound;
     const char *p;
Index: OSC-string-help.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-string-help.h,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- OSC-string-help.h	2000/04/23 08:18:14	1.0.0.1
+++ OSC-string-help.h	2000/04/24 15:16:52	1.1
@@ -68,5 +68,5 @@
    of the result array.  Return FALSE if any strings are malformatted or if
    there are more than maxStrings many strings. */
 
-Boolean OSCParseStringList(const char *result[], int *numStrings, int maxStrings,
+OSCBoolean OSCParseStringList(const char *result[], int *numStrings, int maxStrings,
 			   const char *args, int numBytes);
Index: OSC-timetag.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-timetag.c,v
retrieving revision 1.0.0.1
retrieving revision 1.4
diff -B -b -u -r1.0.0.1 -r1.4
--- OSC-timetag.c	2000/04/23 08:18:15	1.0.0.1
+++ OSC-timetag.c	2000/04/27 14:52:28	1.4
@@ -55,7 +55,7 @@
 OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset) {
     int8 offset = (int8) (secondsOffset * TWO_TO_THE_32_FLOAT);
 
-/*    printf("* OSCTT_PlusSeconds %llx plus %f seconds (i.e., %lld offset) is %llx\n", original,
+  /*    printf("* OSCTT_PlusSeconds %llx plus %f seconds (i.e., %lld offset) is %llx\n", original,
 	      secondsOffset, offset, original + offset);  */
 
     return original + offset;
@@ -75,6 +75,11 @@
     }
 }
 
+void OSCTT_SetFromInt(OSCTimeTag *self, unsigned int value) {
+       if (self != (OSCTimeTag *) NULL)
+               *self = value;
+}
+
 #ifdef __sgi
 #include <sys/time.h>
 
@@ -112,7 +117,7 @@
 
     result += usecOffset;
 
-/*    printf("* OSCTT_CurrentTime is %llx\n", result); */
+  /*    printf("* OSCTT_CurrentTime is %llx\n", result); */
     return result;
 }
 
@@ -133,43 +138,104 @@
 
 #else /* Not HAS8BYTEINT */
 
+#ifdef __linux
+
+#include <math.h>
+#include <sys/time.h>
+
+#define SECONDS_FROM_1900_to_1970 2208988800 /* 17 leap years */
+
+/*
+  Is this right: we do have nanosec precision,
+  thus we convert usecs returned from gettimeofday()
+  to nanosecs ?!!
+*/
 OSCTimeTag OSCTT_CurrentTime(void) {
+  struct timeval tv;
+  struct timezone tz;
     OSCTimeTag result;
-    result.seconds = 0;
-    result.fraction = 1;
+  
+  gettimeofday(&tv, &tz);
+ 
+  /* tz.dsttime deprecated on Linux */
+  result.seconds = tv.tv_sec - 60 * tz.tz_minuteswest + (uint4) SECONDS_FROM_1900_to_1970;
+  result.fraction = (unsigned) tv.tv_usec * (unsigned) 1e3;
     return result;
 }
 
-OSCTimeTag OSCTT_BiggestPossibleTimeTag(void) {
+OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag tt, float secondsOffset) {
+  double abs, frac;
+
+  frac = modf(secondsOffset, &abs);
+
+  tt.seconds  += abs;
+  tt.fraction += frac * 1e9;
+
+  return tt;
+}
+
+#else /* not __linux */
+
+OSCTimeTag OSCTT_CurrentTime(void) {
     OSCTimeTag result;
-    result.seconds = 0xffffffff;
-    result.fraction = 0xffffffff;
+  result.seconds = 0;
+  result.fraction = 1;
     return result;
 }
 
-OSCTimeTag OSCTT_Immediately(void) {
+OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset) {
     OSCTimeTag result;
     result.seconds = 0;
     result.fraction = 1;
     return result;
 }
 
-OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset) {
+#endif /* __linux */
+
+OSCTimeTag OSCTT_BiggestPossibleTimeTag(void) {
     OSCTimeTag result;
+  result.seconds = 0xffffffff;
+  /* result.fraction = 0xffffffff; */
+  result.fraction = 999999999;
+  return result;
+}
+
+OSCTimeTag OSCTT_Immediately(void) {
+  OSCTimeTag result;
     result.seconds = 0;
     result.fraction = 1;
     return result;
 }
 
 int OSCTT_Compare(OSCTimeTag left, OSCTimeTag right) {
-    /* Untested! */
+
+  /*  
+      This puts the result of uint arithmetics
+      into an int var.
+
     int highResult = left.seconds - right.seconds;
 
     if (highResult != 0) return highResult;
 
     return left.fraction - right.fraction;
+  */
+
+  if (left.seconds != right.seconds)
+    return (left.seconds > right.seconds ? 1 : -1);
+  else 
+    if (left.fraction != right.fraction)
+      return (left.fraction > right.fraction ? 1 : -1);
+    else
+      return 0;
 }
 
+void OSCTT_SetFromInt(OSCTimeTag *self, unsigned int value) {
+       if (self != (OSCTimeTag *) NULL) {
+               self->seconds = 0;
+               self->fraction = value & 0xffffffff;
+       }
+}
 
 #endif /* HAS8BYTEINT */
+
 
Index: OSC-timetag.h
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/OSC-timetag.h,v
retrieving revision 1.0.0.1
retrieving revision 1.2
diff -B -b -u -r1.0.0.1 -r1.2
--- OSC-timetag.h	2000/04/23 08:18:15	1.0.0.1
+++ OSC-timetag.h	2000/04/27 14:52:28	1.2
@@ -90,4 +90,8 @@
    they're equal, and positive if first > second. */
 int OSCTT_Compare(OSCTimeTag left, OSCTimeTag right);
 
+/* Set from an unsigned int. This is to be able to run smoothly on
+   a non 8-byte int machine [added by nicb@axnet.it] */
+void OSCTT_SetFromInt(OSCTimeTag *self, unsigned int value);
+
 #endif /*  OSC_TIMETAG */
Index: OSC.h
===================================================================
RCS file: OSC.h
diff -N OSC.h
--- /dev/null	Mon Jul 18 01:46:18 1994
+++ /tmp/cvs24954Qaa	Fri Aug 11 10:34:41 2000
@@ -0,0 +1,35 @@
+/*
+ * $Id$
+ *
+ * This is to provide a decent wrapper to the OSC header files,
+ * at least on a temporary basis... [nicb@axnet.it]
+ *
+ * This is supposed to go in <local-include>/OSC, along with the other
+ * OSC header files
+ */
+#if !defined(_OSC_OSC_h_)
+#	define _OSC_OSC_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#if defined(TRUE)
+#	undef TRUE		/* otherwise we will lose some typedefing */
+#endif  /* defined(TRUE) */
+#if defined(FALSE)
+#	undef FALSE		/* same as above */
+#endif /* defined(FALSE) */
+
+#include <OSC/OSC-common.h>
+
+#include <OSC/OSC-timetag.h>
+#include <OSC/OSC-address-space.h>
+#include <OSC/OSC-receive.h>
+#include <OSC/NetworkUDP.h>
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* !defined(_OSC_OSC_h_) */
Index: simplesynth-osc.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/simplesynth-osc.c,v
retrieving revision 1.0.0.1
retrieving revision 1.2
diff -B -b -u -r1.0.0.1 -r1.2
--- simplesynth-osc.c	2000/04/23 08:18:17	1.0.0.1
+++ simplesynth-osc.c	2000/04/24 15:16:52	1.2
@@ -45,12 +45,16 @@
 /* for select(2) */
 #include <unistd.h>
 #include <sys/types.h>
-#include <bstring.h>
+#if !defined(HAS_NO_BSTRING_H)
+#	include <bstring.h>
+#endif /* defined(HAS_NO_BSTRING_H) */
 #include <sys/time.h>
 
 #include <audio.h>         /* SGI audio library */
+#if !defined(LINUX)
 #include <sys/schedctl.h>  /* for scheduler control */
 #include <sys/lock.h>      /* for memory lock */
+#endif /* !defined(LINUX) */
 
 #include <math.h>
 #define PI 3.14159265358979323
@@ -164,6 +168,10 @@
     }
 }
 
+/*
+ * linux has different system calls for scheduling priority handling
+ */
+#if !defined(LINUX)
 void InitPriority(void) {
     /* set process priority high */
     if (schedctl (NDPRI,getpid(), NDPHIMIN) < 0)
@@ -176,6 +184,11 @@
        user id to avoid security problems */
     setuid(getuid());
 }
+#else /* defined(LINUX) */
+void InitPriority(void) {
+    /* empty until someone has some time to work on it... */
+}
+#endif /* !defined(LINUX) */
 
 float the_sample_rate;
 
@@ -262,8 +275,10 @@
 	OSCInvokeAllMessagesThatAreReady(OSCTT_PlusSeconds(OSCTT_CurrentTime(), 
 							   ALgetfilled(alp) / the_sample_rate));
 
+#if !defined(LINUX)/* ALsetfillpoint is not defined in the libaudio I have */
 	/* set the low water mark, i.e. when we want control from select(2) */
 	ALsetfillpoint(alp, OUTPUTQUEUESIZE - lwm);
+#endif /* !defined(LINUX) */
 
 	/* set up select */
 	FD_ZERO(&read_fds);	/* clear read_fds */
@@ -333,7 +348,7 @@
 void ScaleMethod(void *vs, int arglen, const void *vargs, OSCTimeTag when, NetworkReturnAddressPtr ra) {
     int i;
     OSCTimeTag now = OSCTT_CurrentTime();
-    Boolean r;
+    OSCBoolean r;
 
     float newarg[1];
     float *ptrToArgs[1];
@@ -379,7 +394,7 @@
 void AllMyStringsMethod(void *dummy, int arglen, const void *args, OSCTimeTag when, NetworkReturnAddressPtr ra) {
     char *strings[MAX_NUM_STRINGS];
     int numFound;
-    Boolean r;
+    OSCBoolean r;
     int i;
 
     r = OSCParseStringList(strings, &numFound, MAX_NUM_STRINGS, args, arglen);
@@ -396,7 +411,7 @@
 }
 
 void InitOSCAddrSpace(SynthState *v1, SynthState *v2) {
-    Boolean result;
+    OSCBoolean result;
     OSCcontainer OSCTopLevelContainer, sine1, sine2;
     struct OSCAddressSpaceMemoryTuner t;
     struct OSCContainerQueryResponseInfoStruct cqinfo;
@@ -430,7 +445,7 @@
 
 void InitOSCReceive() {
     struct OSCReceiveMemoryTuner rt;
-    Boolean result;
+    OSCBoolean result;
 
     rt.InitTimeMemoryAllocator = MyInitTimeMalloc;
     rt.RealTimeMemoryAllocator = MyRealTimeMalloc;
@@ -454,7 +469,7 @@
 }
 
 
-void main() {
+int main() {
     ALport alp;
     FileDescriptor dacfd, sockfd;	
     int udp_port = 7000;
@@ -476,4 +491,6 @@
     InitOSC(voices, voices+1);
 
     MainLoop(alp, dacfd, sockfd, voices, voices+1);
+
+    return 0;
 }
Index: test-priority-queue.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/test-priority-queue.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- test-priority-queue.c	2000/04/23 08:18:17	1.0.0.1
+++ test-priority-queue.c	2000/04/23 08:43:10	1.1
@@ -102,7 +102,7 @@
     printf("\n\nStress Test...\n\n");
 
     for (i = 1; i < NUM_OBJS; ++i) {
-	objects[i].timetag = rand();
+	OSCTT_SetFromInt(&objects[i].timetag, rand());
 	objects[i].data = "stress test";
 
 	if (OSCQueueInsert(q, (OSCSchedulableObject) &(objects[i])) == FALSE) {
@@ -120,14 +120,14 @@
 	}
     }
 
-    while (OSCQueueEarliestTimeTag(q) != OSCTT_BiggestPossibleTimeTag()) {
+    while (OSCTT_Compare(OSCQueueEarliestTimeTag(q), OSCTT_BiggestPossibleTimeTag())) {
 	item = (myObj *) OSCQueueRemoveEarliest(q);
 	printf("next from queue: %llu\n", item->timetag);
     }
 }
 	
 
-void main (void) {
+int main (void) {
     OSCQueue q;
     myObj *item;
 
@@ -141,11 +141,11 @@
     OSCQueuePrint(q);
 
     printf("Inserting three objects.\n");
-    objects[0].timetag = 5;
+    OSCTT_SetFromInt(&objects[0].timetag, 5);
     objects[0].data = "five";
-    objects[1].timetag = 2;
+    OSCTT_SetFromInt(&objects[1].timetag, 2);
     objects[1].data = "two";
-    objects[2].timetag = 7;
+    OSCTT_SetFromInt(&objects[2].timetag, 7);
     objects[2].data = "seven";
 
     if (OSCQueueInsert(q, (OSCSchedulableObject) &(objects[0])) == FALSE) {
@@ -177,11 +177,11 @@
     OSCQueuePrint(q);
 
     printf("Inserting three more objects.\n");
-    objects[3].timetag = 11;
+    OSCTT_SetFromInt(&objects[3].timetag, 11);
     objects[3].data = "eleven";
-    objects[4].timetag = 6;
+    OSCTT_SetFromInt(&objects[4].timetag, 6);
     objects[4].data = "six";
-    objects[5].timetag = 3;
+    OSCTT_SetFromInt(&objects[5].timetag, 3);
     objects[5].data = "three";
     
     if (OSCQueueInsert(q, (OSCSchedulableObject) &(objects[3])) == FALSE) {
@@ -209,4 +209,5 @@
 
     printf("Done!\n");
 
+    return 0;
 }
Index: testOSC.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/testOSC.c,v
retrieving revision 1.0.0.1
retrieving revision 1.2
diff -B -b -u -r1.0.0.1 -r1.2
--- testOSC.c	2000/04/23 08:18:18	1.0.0.1
+++ testOSC.c	2000/04/24 15:16:52	1.2
@@ -50,7 +50,7 @@
 
 void SetUpAddrSpace(void);
 void TestEmptyCase();
-void PretendToGetPacket();
+int   PretendToGetPacket();
 
 OSCcontainer OSCTopLevelContainer;
 
@@ -63,8 +63,8 @@
 }
 
 
-void main() {
-    Boolean result;
+int main() {
+    OSCBoolean result;
     struct OSCAddressSpaceMemoryTuner t;
     struct OSCReceiveMemoryTuner rt;
 
@@ -254,7 +254,10 @@
 
 void TestEmptyCase() {
     printf("Calling OSCInvokeMessagesThatAreReady, even though nothing's ready.\n");
+#if 0
     OSCInvokeMessagesThatAreReady(2);
+#endif
+    OSCInvokeMessagesThatAreReady(OSCTT_PlusSeconds(OSCTT_CurrentTime(), 2));
 }
 
 
@@ -270,7 +273,7 @@
     "b\0\0\0";
 
 
-void PretendToGetPacket() {
+int PretendToGetPacket() {
     OSCPacketBuffer p;
     char *buf;
     int *size;
@@ -296,5 +299,10 @@
     OSCBeProductiveWhileWaiting();
 
     printf("Calling OSCInvokeMessagesThatAreReady(0xffffffff)\n");
+#if 0
     OSCInvokeMessagesThatAreReady(0xffffffff);
+#endif
+    OSCInvokeMessagesThatAreReady(OSCTT_BiggestPossibleTimeTag());
+
+    return 0;
 }
Index: send+dump/Makefile.linux
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/send+dump/Makefile.linux,v
retrieving revision 1.0.0.1
retrieving revision 1.3
diff -B -b -u -r1.0.0.1 -r1.3
--- send+dump/Makefile.linux	2000/04/23 08:18:18	1.0.0.1
+++ send+dump/Makefile.linux	2000/08/11 08:32:01	1.3
@@ -0,0 +1,18 @@
+CC=gcc
+DEFINES=-DHAS_NO_BSTRING_H -DLINUX -I..
+CFLAGS=  -O2 ${DEFINES}
+LDFLAGS= -L../..
+LIBS=-lOSC
+SENDOBJS=sendOSC.o htmsocket.o
+DUMPOBJS=dumpOSC.o
+
+all:	sendOSC dumpOSC
+
+sendOSC: ${SENDOBJS}
+	${CC} ${LDFLAGS} -o $@ ${SENDOBJS} ${LIBS}
+
+dumpOSC: ${DUMPOBJS}
+	${CC} -o $@ ${DUMPOBJS}
+	
+clean:
+	${RM} ${SENDOBJS} ${DUMPOBJS} sendOSC dumpOSC
Index: send+dump/OSC-client.c
===================================================================
RCS file: OSC-client.c
diff -N OSC-client.c
--- /tmp/cvs24954Zaa	Fri Aug 11 10:34:41 2000
+++ /dev/null	Mon Jul 18 01:46:18 1994
@@ -1,303 +0,0 @@
-/*
-Copyright (c) 1996.  The Regents of the University of California (Regents).
-All Rights Reserved.
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for educational, research, and not-for-profit purposes, without
-fee and without a signed licensing agreement, is hereby granted, provided that
-the above copyright notice, this paragraph and the following two paragraphs
-appear in all copies, modifications, and distributions.  Contact The Office of
-Technology Licensing, UC Berkeley, 2150 Shattuck Avenue, Suite 510, Berkeley,
-CA 94720-1620, (510) 643-7201, for commercial licensing opportunities.
-
-Written by Matt Wright, The Center for New Music and Audio Technologies,
-University of California, Berkeley.
-
-     IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
-     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
-     ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
-     REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
-     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
-     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".
-     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
-     ENHANCEMENTS, OR MODIFICATIONS.
-*/
-
-
-/* 
-  Author: Matt Wright
-  Version 2.1
- */
-
-
-/* Here are the possible values of the state field: */
-
-#define EMPTY 0	       /* Nothing written to packet yet */
-#define ONE_MSG_ARGS 1 /* Packet has a single message; gathering arguments */
-#define NEED_COUNT 2   /* Just opened a bundle; must write message name or
-			  open another bundle */
-#define GET_ARGS 3     /* Getting arguments to a message.  If we see a message
-			  name or a bundle open/close then the current message
-			  will end. */
-#define DONE 4         /* All open bundles have been closed, so can't write 
-		          anything else */
-
-#include "OSC-client.h"
-
-char *OSC_errorMessage;
-
-
-static int strlen(char *s);
-static int OSC_padString(char *dest, char *str);
-
-void OSC_initBuffer(OSCbuf *buf, int size, char *byteArray) {
-    buf->buffer = byteArray;
-    buf->size = size;
-    OSC_resetBuffer(buf);
-}
-
-void OSC_resetBuffer(OSCbuf *buf) {	
-    buf->bufptr = buf->buffer;
-    buf->state = EMPTY;
-    buf->bundleDepth = 0;
-    buf->prevCounts[0] = 0;
-}
-
-int OSC_isBufferEmpty(OSCbuf *buf) {
-    return buf->bufptr == buf->buffer;
-}
-
-int OSC_freeSpaceInBuffer(OSCbuf *buf) {
-    return buf->size - (buf->bufptr - buf->buffer);
-}
-
-int OSC_isBufferDone(OSCbuf *buf) {
-    return (buf->state == DONE || buf->state == ONE_MSG_ARGS);
-}
-
-char *OSC_getPacket(OSCbuf *buf) {
-#ifdef ERROR_CHECK_GETPACKET
-    if (buf->state == DONE || buf->state == ONE_MSG_ARGS) {
-	return buf->buffer;
-    } else {
-	OSC_errorMessage = "Packet has unterminated bundles";
-	return 0;
-    }
-#else
-    return buf->buffer;
-#endif
-}
-
-int OSC_packetSize(OSCbuf *buf) {
-#ifdef ERROR_CHECK_PACKETSIZE
-    if (buf->state == DONE || buf->state == ONE_MSG_ARGS) {
-	return (buf->bufptr - buf->buffer);
-    } else {
-        OSC_errorMessage = "Packet has unterminated bundles";
-        return 0;
-    }
-#else
-    return (buf->bufptr - buf->buffer);
-#endif
-}
-
-#define CheckOverflow(buf, bytesNeeded) { \
-    if ((bytesNeeded) > OSC_freeSpaceInBuffer(buf)) { \
-	OSC_errorMessage = "buffer overflow"; \
-	return 1; \
-    } \
-}
-
-static void PatchMessageSize(OSCbuf *buf) {
-    int4byte size;
-    size = buf->bufptr - ((char *) buf->thisMsgSize) - 4;
-    *(buf->thisMsgSize) = size;
-}
-
-int OSC_openBundle(OSCbuf *buf, OSCTimeTag tt) {
-    if (buf->state == ONE_MSG_ARGS) {
-	OSC_errorMessage = "Can't open a bundle in a one-message packet";
-	return 3;
-    }
-
-    if (buf->state == DONE) {
-	OSC_errorMessage = "This packet is finished; can't open a new bundle";
-	return 4;
-    }
-
-    if (++(buf->bundleDepth) >= MAX_BUNDLE_NESTING) {
-	OSC_errorMessage = "Bundles nested too deeply; change MAX_BUNDLE_NESTING in OpenSoundControl.h";
-	return 2;
-    }
-
-    if (buf->state == GET_ARGS) {
-	PatchMessageSize(buf);
-    }
-
-    if (buf->state == EMPTY) {
-	/* Need 16 bytes for "#bundle" and time tag */
-	CheckOverflow(buf, 16);
-    } else {
-	/* This bundle is inside another bundle, so we need to leave
-	   a blank size count for the size of this current bundle. */
-	CheckOverflow(buf, 20);
-	*((int4byte *)buf->bufptr) = 0xaaaaaaaa;
-        buf->prevCounts[buf->bundleDepth] = (int4byte *)buf->bufptr;
-
-	buf->bufptr += 4;
-    }
-
-    buf->bufptr += OSC_padString(buf->bufptr, "#bundle");
-    *((OSCTimeTag *) buf->bufptr) = tt;
-    buf->bufptr += sizeof(OSCTimeTag);
-
-    buf->state = NEED_COUNT;
-    return 0;
-}
-
-
-int OSC_closeBundle(OSCbuf *buf) {
-    if (buf->bundleDepth == 0) {
-	/* This handles EMPTY, ONE_MSG, ARGS, and DONE */
-	OSC_errorMessage = "Can't close bundle; no bundle is open!";
-	return 5;
-    }
-
-    if (buf->state == GET_ARGS) {
-        PatchMessageSize(buf);
-    }
-
-    if (buf->bundleDepth == 1) {
-	/* Closing the last bundle: No bundle size to patch */
-	buf->state = DONE;
-    } else {
-	/* Closing a sub-bundle: patch bundle size */
-	int size = buf->bufptr - ((char *) buf->prevCounts[buf->bundleDepth]) - 4;
-	*(buf->prevCounts[buf->bundleDepth]) = size;
-	buf->state = NEED_COUNT;
-    }
-
-    --buf->bundleDepth;
-    return 0;
-}
-	
-
-int OSC_closeAllBundles(OSCbuf *buf) {
-    if (buf->bundleDepth == 0) {
-        /* This handles EMPTY, ONE_MSG, ARGS, and DONE */
-        OSC_errorMessage = "Can't close all bundles; no bundle is open!";
-        return 6;
-    }
-
-    while (buf->bundleDepth > 0) {
-	OSC_closeBundle(buf);
-    }
-    return 0;
-}
-
-int OSC_writeAddress(OSCbuf *buf, char *name) {
-    int4byte paddedLength;
-
-    if (buf->state == ONE_MSG_ARGS) {
-	OSC_errorMessage = "This packet is not a bundle, so you can't write another address";
-	return 7;
-    }
-
-    if (buf->state == DONE) {
-        OSC_errorMessage = "This packet is finished; can't write another address";
-        return 8;
-    }
-
-    paddedLength = OSC_effectiveStringLength(name);
-
-    if (buf->state == EMPTY) {
-	/* This will be a one-message packet, so no sizes to worry about */
-	CheckOverflow(buf, paddedLength);
-	buf->state = ONE_MSG_ARGS;
-    } else {
-	/* GET_ARGS or NEED_COUNT */
-	CheckOverflow(buf, 4+paddedLength);
-	if (buf->state == GET_ARGS) {
-	    /* Close the old message */
-	    PatchMessageSize(buf);
-	}
-	buf->thisMsgSize = (int4byte *)buf->bufptr;
-	*(buf->thisMsgSize) = 0xbbbbbbbb;
-	buf->bufptr += 4;
-	buf->state = GET_ARGS;
-    }
-
-    /* Now write the name */
-    buf->bufptr += OSC_padString(buf->bufptr, name);
-    return 0;
-}
-
-int OSC_writeFloatArg(OSCbuf *buf, float arg) {
-    CheckOverflow(buf, 4);
-    *((float *) buf->bufptr) = arg;
-    buf->bufptr += 4;
-    return 0;
-}
-
-int OSC_writeFloatArgs(OSCbuf *buf, int numFloats, float *args) {
-    int i;
-    CheckOverflow(buf, 4 * numFloats);
-    for (i = 0; i < numFloats; i++) {
-	*((float *) buf->bufptr) = args[i];
-	buf->bufptr += 4;
-    }
-    return 0;
-}
-
-int OSC_writeIntArg(OSCbuf *buf, int4byte arg) {
-    CheckOverflow(buf, 4);
-    *((int4byte *) buf->bufptr) = arg;
-    buf->bufptr += 4;
-    return 0;
-}
-
-int OSC_writeStringArg(OSCbuf *buf, char *arg) {
-    CheckOverflow(buf, OSC_effectiveStringLength(arg));
-    buf->bufptr += OSC_padString(buf->bufptr, arg);
-    return 0;
-}
-
-/* String utilities */
-
-static int strlen(char *s) {
-    int i;
-    for (i=0; s[i] != '\0'; i++) /* Do nothing */ ;
-    return i;
-}
-
-#define STRING_ALIGN_PAD 4
-int OSC_effectiveStringLength(char *string) {
-    int len = strlen(string) + 1;  /* We need space for the null char. */
-    
-    /* Round up len to next multiple of STRING_ALIGN_PAD to account for alignment padding */
-    if ((len % STRING_ALIGN_PAD) != 0) {
-        len += STRING_ALIGN_PAD - (len % STRING_ALIGN_PAD);
-    }
-    return len;
-}
-
-static int OSC_padString(char *dest, char *str) {
-    int i;
-    
-    for (i = 0; str[i] != '\0'; i++) {
-        dest[i] = str[i];
-    }
-    
-    dest[i] = '\0';
-    i++;
-    
-    for (; (i % STRING_ALIGN_PAD) != 0; i++) {
-        dest[i] = '\0';
-    }
-    
-    return i;
-}
- 
Index: send+dump/OSC-client.h
===================================================================
RCS file: OSC-client.h
diff -N OSC-client.h
--- /tmp/cvs249540aa	Fri Aug 11 10:34:41 2000
+++ /dev/null	Mon Jul 18 01:46:18 1994
@@ -1,169 +0,0 @@
-/*
-Copyright (c) 1996,1997.  The Regents of the University of California (Regents).
-All Rights Reserved.
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for educational, research, and not-for-profit purposes, without
-fee and without a signed licensing agreement, is hereby granted, provided that
-the above copyright notice, this paragraph and the following two paragraphs
-appear in all copies, modifications, and distributions.  Contact The Office of
-Technology Licensing, UC Berkeley, 2150 Shattuck Avenue, Suite 510, Berkeley,
-CA 94720-1620, (510) 643-7201, for commercial licensing opportunities.
-
-Written by Matt Wright, The Center for New Music and Audio Technologies,
-University of California, Berkeley.
-
-     IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
-     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
-     ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
-     REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
-     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
-     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".
-     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
-     ENHANCEMENTS, OR MODIFICATIONS.
-*/
-
-/* 
-
-   OSC-client.h: library for constructing OpenSoundControl messages.
-   Derived from SynthControl.h
-   Author: Matt Wright
-   Version 0.1: 6/13/97
-
-
-   General notes:
-
-   This library abstracts away the data format for the OpenSoundControl
-   protocol.  Users of this library can construct OpenSoundControl packets
-   with a function call interface instead of knowing how to lay out the bits.
-
-   All issues of memory allocation are deferred to the user of this library.
-   There are two data structures that the user must allocate.  The first
-   is the actual buffer that the message will be written into.  This buffer
-   can be any size, but if it's too small there's a possibility that it
-   will become overfull.  The other data structure is called an OSCbuf,
-   and it holds all the state used by the library as it's constructing
-   a buffer.
-
-   All procedures that have the possibility of an error condition return int,
-   with 0 indicating no error and nonzero indicating an error.  The variable
-   OSC_errorMessage will be set to point to a string containing an error
-   message explaining what the problem is.
-
-*/
-
-#include "OSC_timeTag.h"
-
-/* The int4byte type has to be a 4-byte integer.  You may have to
-   change this to long or something else on your system.  */
-#ifdef __MWERKS__
-  /* In Metrowerks you can set ints to be 2 or 4 bytes on 68K, but long is
-     always 4 bytes */
-    typedef long int4byte;
-#else
-    typedef int int4byte;
-#endif
-
-/* The maximum depth of bundles within bundles within bundles within...
-   This is the size of a static array.  If you exceed this limit you'll 
-   get an error message. */
-#define MAX_BUNDLE_NESTING 32
-
-
-/* Don't ever manipulate the data in the OSCbuf struct directly.  (It's
-   declared here in the header file only so your program will be able to
-   declare variables of type OSCbuf and have the right amount of memory
-   be allocated.) */
-
-typedef struct OSCbuf_struct {
-    char *buffer;            /* The buffer to hold the OSC packet */
-    int size;                /* Size of the buffer */
-    char *bufptr;            /* Current position as we fill the buffer */
-    int state;		     /* State of half-constructed message */
-    int4byte *thisMsgSize;   /* Pointer to count field before 
-			        currently-being-written message */
-    int4byte *prevCounts[MAX_BUNDLE_NESTING];
-			     /* Pointers to count field before each currently
-			        open bundle */
-    int bundleDepth;	     /* How many sub-sub-bundles are we in now? */
-} OSCbuf;
-
-
-/* Initialize the given OSCbuf.  The user of this module must pass in the
-   block of memory that this OSCbuf will use for a buffer, and the number of
-   bytes in that block.  (It's the user's job to allocate the memory because
-   you do it differently in different systems.) */
-void OSC_initBuffer(OSCbuf *buf, int size, char *byteArray);
-
-
-/* Reset the given OSCbuf.  Do this after you send out the contents of
-   the buffer and want to start writing new data into it. */
-void OSC_resetBuffer(OSCbuf *buf);
-
-
-/* Is the buffer empty?  (I.e., would it be stupid to send the buffer
-   contents to the synth?) */
-int OSC_isBufferEmpty(OSCbuf *buf);
-
-
-/* How much space is left in the buffer? */
-int OSC_freeSpaceInBuffer(OSCbuf *buf);
-
-/* Does the buffer contain a valid OSC packet?  (Returns nonzero if yes.) */
-int OSC_isBufferDone(OSCbuf *buf);
-
-/* When you're ready to send out the buffer (i.e., when OSC_isBufferDone()
-   returns true), call these two procedures to get the OSC packet that's been
-   assembled and its size in bytes.  (And then call OSC_resetBuffer() if you
-   want to re-use this OSCbuf for the next packet.)  */
-char *OSC_getPacket(OSCbuf *buf);
-int OSC_packetSize(OSCbuf *buf);
-
-
-
-/* Here's the basic model for building up OSC messages in an OSCbuf:
-
-    - Make sure the OSCbuf has been initialized with OSC_initBuffer().
-
-    - To open a bundle, call OSC_openBundle().  You can then write 
-      messages or open new bundles within the bundle you opened.
-      Call OSC_closeBundle() to close the bundle.  Note that a packet
-      does not have to have a bundle; it can instead consist of just a 
-      single message.
-								  
-
-    - For each message you want to send:
-
-	- Call OSC_writeAddress() with the name of your message.  (In
-	  addition to writing your message name into the buffer, this
-	  procedure will also leave space for the size count of this message.)
-	
-	- Now write each of the arguments into the buffer, by calling one of:
-	    OSC_writeFloatArg()
-	    OSC_writeFloatArgs()
-	    OSC_writeIntArg()
-	    OSC_writeStringArg()
-
-	- Now your message is complete; you can send out the buffer or you can
-	  add another message to it.
-*/
-
-int OSC_openBundle(OSCbuf *buf, OSCTimeTag tt);
-int OSC_closeBundle(OSCbuf *buf);
-int OSC_closeAllBundles(OSCbuf *buf);
-
-int OSC_writeAddress(OSCbuf *buf, char *name);
-int OSC_writeFloatArg(OSCbuf *buf, float arg);
-int OSC_writeFloatArgs(OSCbuf *buf, int numFloats, float *args);
-int OSC_writeIntArg(OSCbuf *buf, int4byte arg);
-int OSC_writeStringArg(OSCbuf *buf, char *arg);
-
-extern char *OSC_errorMessage;
-
-/* How many bytes will be needed in the OSC format to hold the given
-   string?  The length of the string, plus the null char, plus any padding
-   needed for 4-byte alignment. */ 
-int OSC_effectiveStringLength(char *string);
Index: send+dump/OSC_timeTag.c
===================================================================
RCS file: OSC_timeTag.c
diff -N OSC_timeTag.c
--- /tmp/cvs249541aa	Fri Aug 11 10:34:41 2000
+++ /dev/null	Mon Jul 18 01:46:18 1994
@@ -1,132 +0,0 @@
-/*
-Copyright (c) 1997.  The Regents of the University of California (Regents).
-All Rights Reserved.
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for educational, research, and not-for-profit purposes, without
-fee and without a signed licensing agreement, is hereby granted, provided that
-the above copyright notice, this paragraph and the following two paragraphs
-appear in all copies, modifications, and distributions.  Contact The Office of
-Technology Licensing, UC Berkeley, 2150 Shattuck Avenue, Suite 510, Berkeley,
-CA 94720-1620, (510) 643-7201, for commercial licensing opportunities.
-
-Written by Matt Wright, The Center for New Music and Audio Technologies,
-University of California, Berkeley.
-
-     IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
-     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
-     ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
-     REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
-     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
-     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".
-     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
-     ENHANCEMENTS, OR MODIFICATIONS.
-*/
-
-/*
-
- OSC_timeTag.c: library for manipulating OSC time tags
- Matt Wright, 5/29/97
-
- Version 0.1: Has loser versions for non-SGI case
-
-*/
-
-#include "OSC_timeTag.h"
-
-#ifdef __sgi
-#include <sys/time.h>
-
-#define SECONDS_FROM_1900_to_1970 2208988800 /* 17 leap years */
-#define TWO_TO_THE_32_FLOAT 4294967296.0f
-#define TWO_TO_THE_32_OVER_ONE_MILLION 4295
-
-
-OSCTimeTag OSCTT_CurrentTime(void) {
-    unsigned long long result;
-    unsigned long usecOffset;
-    struct timeval tv;
-    struct timezone tz;
-
-    BSDgettimeofday(&tv, &tz);
-
-    /* First get the seconds right */
-    result = (unsigned) SECONDS_FROM_1900_to_1970 + 
-	     (unsigned) tv.tv_sec - 
-	     (unsigned) 60 * tz.tz_minuteswest +
-             (unsigned) (tz.tz_dsttime ? 3600 : 0);
-
-#if 0
-    /* No timezone, no DST version ... */
-    result = (unsigned) SECONDS_FROM_1900_to_1970 + 
-	     (unsigned) tv.tv_sec;
-#endif
-
-
-    /* make seconds the high-order 32 bits */
-    result = result << 32;
-	
-    /* Now get the fractional part. */
-    usecOffset = (unsigned) tv.tv_usec * (unsigned) TWO_TO_THE_32_OVER_ONE_MILLION;
-    /* printf("** %ld microsec is offset %x\n", tv.tv_usec, usecOffset); */
-
-    result += usecOffset;
-    return result;
-}
-
-OSCTimeTag OSCTT_Immediately(void) {
-    return (OSCTimeTag) 1;
-}
-
-OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset) {
-    long long offset = (long long) (secondsOffset * TWO_TO_THE_32_FLOAT);
-    /* printf("%llu plus %f seconds (i.e., %lld offset)\n", original,
-	      secondsOffset, offset); */
-    return original + offset;
-}
-
-#else /* __sgi */
-/* Loser versions for systems that have no ability to tell the current time: */
-
-#ifdef HAS8BYTEINT
-
-OSCTimeTag OSCTT_CurrentTime(void) {
-    return (OSCTimeTag) 1;
-}
-
-OSCTimeTag OSCTT_Immediately(void) {
-    return (OSCTimeTag) 1;
-}
-
-OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset) {
-    return (OSCTimeTag) 1;
-}
-
-#else /* Not HAS8BYTEINT */
-
-OSCTimeTag OSCTT_CurrentTime(void) {
-    OSCTimeTag result;
-    result.seconds = 0;
-    result.fraction = 1;
-    return result;
-}
-
-OSCTimeTag OSCTT_Immediately(void) {
-    OSCTimeTag result;
-    result.seconds = 0;
-    result.fraction = 1;
-    return result;
-}
-
-OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset) {
-    OSCTimeTag result;
-    result.seconds = 0;
-    result.fraction = 1;
-    return result;
-}
-#endif /* HAS8BYTEINT */
-#endif /* __sgi */
-
Index: send+dump/OSC_timeTag.h
===================================================================
RCS file: OSC_timeTag.h
diff -N OSC_timeTag.h
--- /tmp/cvs249542aa	Fri Aug 11 10:34:41 2000
+++ /dev/null	Mon Jul 18 01:46:18 1994
@@ -1,81 +0,0 @@
-/*
-Copyright (c) 1997.  The Regents of the University of California (Regents).
-All Rights Reserved.
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for educational, research, and not-for-profit purposes, without
-fee and without a signed licensing agreement, is hereby granted, provided that
-the above copyright notice, this paragraph and the following two paragraphs
-appear in all copies, modifications, and distributions.  Contact The Office of
-Technology Licensing, UC Berkeley, 2150 Shattuck Avenue, Suite 510, Berkeley,
-CA 94720-1620, (510) 643-7201, for commercial licensing opportunities.
-
-Written by Matt Wright, The Center for New Music and Audio Technologies,
-University of California, Berkeley.
-
-     IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
-     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
-     ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
-     REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
-     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
-     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".
-     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
-     ENHANCEMENTS, OR MODIFICATIONS.
-*/
-
-/*
- OSC_timeTag.h: library for manipulating OSC time tags
- Matt Wright, 5/29/97
-
- Time tags in OSC have the same format as in NTP: 64 bit fixed point, with the
- top 32 bits giving number of seconds sinve midnight 1/1/1900 and the bottom
- 32 bits giving fractional parts of a second.  We represent this by an 8-byte
- unsigned long if possible, or else a struct. 
-*/
-
-#ifndef OSC_TIMETAG
-#define OSC_TIMETAG
-
-#ifdef __sgi
-    #define HAS8BYTEINT
-    /* You may have to change this typedef if there's some other
-       way to specify 8 byte ints on your system */
-    typedef unsigned long long uint8;
-#else
-    /* You may have to redefine this typedef if ints on your system 
-       aren't 4 bytes. */
-    typedef unsigned int uint4;
-#endif
-
-
-#ifdef HAS8BYTEINT
-    typedef uint8 OSCTimeTag;
-#else
-    typedef struct {
-	uint4 seconds;
-	uint4 fraction;
-    } OSCTimeTag;
-#endif
-
-
-
-/* Return a time tag representing the current time (as of when this
-   procedure is called). */
-OSCTimeTag OSCTT_CurrentTime(void);
-
-/* Return a time tag from a time in the past, indicating to the receiving
-   device that it should process the message immediately. */
-OSCTimeTag OSCTT_Immediately(void);
-
-/* Given a time tag and a number of seconds to add to the time tag, return
-   the new time tag */
-OSCTimeTag OSCTT_PlusSeconds(OSCTimeTag original, float secondsOffset);
-
-/* Compare two time tags.  Return negative if first is < second, 0 if
-   they're equal, and positive if first > second. */
-int OSCTT_Compare(OSCTimeTag left, OSCTimeTag right);
-
-#endif /*  OSC_TIMETAG */
Index: send+dump/dumpOSC.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/send+dump/dumpOSC.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- send+dump/dumpOSC.c	2000/04/23 08:18:21	1.0.0.1
+++ send+dump/dumpOSC.c	2000/04/23 08:43:10	1.1
@@ -53,7 +53,7 @@
 
 */
 
-#ifdef __sgi
+#if defined(__sgi) || defined(LINUX)
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -76,10 +76,14 @@
 #include <signal.h>
 #include <grp.h>
 #include <sys/file.h>
-#include <bstring.h>
+#if !defined(HAS_NO_BSTRING_H)
+#	include <bstring.h>
+#endif /* !defined(HAS_NO_BSTRING_H) */
 #include <sys/prctl.h>
+#if 0
 #include <sys/schedctl.h>
 #include <sys/lock.h>
+#endif
 
 
 char *htm_error_string;
@@ -457,7 +461,7 @@
 #define MAXMESG 32768
 static char mbuf[MAXMESG];
 
-void main(int argc,  char **argv) {
+int main(int argc,  char **argv) {
     int udp_port;		/* port to receive parameter updates from */
 		
 	char *mktemp;
@@ -600,6 +604,8 @@
 	}
 	else
 		perror("initudp");
+
+	return 0;
 }   
 
 
Index: send+dump/htmsocket.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/send+dump/htmsocket.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- send+dump/htmsocket.c	2000/04/23 08:18:21	1.0.0.1
+++ send+dump/htmsocket.c	2000/04/23 08:43:10	1.1
@@ -38,7 +38,11 @@
 
 
 #include <stdio.h>
-#include <bstring.h>
+#if !defined(HAS_NO_BSTRING_H)
+#	include <bstring.h>
+#else /* defined(HAS_NO_BSTRING_H) */
+#	include <string.h>
+#endif /* !defined(HAS_NO_BSTRING_H) */
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -60,12 +64,18 @@
 #include <grp.h>
 #include <sys/fcntl.h>
 #include <sys/file.h>
-#include <bstring.h>
+#if !defined(HAS_NO_BSTRING_H)
+#	include <bstring.h>
+#else /* defined(HAS_NO_BSTRING_H) */
+#	include <string.h>
+#endif /* !defined(HAS_NO_BSTRING_H) */
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/prctl.h>
+#if 0
 #include <sys/schedctl.h>
 #include <sys/lock.h>
+#endif
 
 
 #include <stdlib.h>
@@ -214,7 +224,13 @@
 static  bool sendudp(caddr_t *sp, int sockfd,int length, int count, void  *b)
 {
 	int rcount;
-	if((rcount=sendto(sockfd, b, count, 0,sp, length)) != count)
+#if defined(LINUX)
+	struct sockaddr *SP = (struct sockaddr *) sp;
+#else /* !defined(LINUX) */
+#	define SP	sp
+#endif /* defined(LINUX) */
+
+	if((rcount=sendto(sockfd, b, count, 0,SP, length)) != count)
 	{
 /*	printf("sockfd %d count %d rcount %dlength %d errno %d\n", sockfd,count,rcount,length,
 			errno); */
Index: send+dump/makefile
===================================================================
RCS file: makefile
diff -N makefile
--- /tmp/cvs249547aa	Fri Aug 11 10:34:41 2000
+++ /dev/null	Mon Jul 18 01:46:18 1994
@@ -1,8 +0,0 @@
-CFLAGS=  -O2 
-
-sendOSC: sendOSC.o htmsocket.o OSC-client.o OSC_timeTag.o
-	cc -o sendOSC sendOSC.o htmsocket.o OSC-client.o OSC_timeTag.o
-
-dumpOSC: dumpOSC.c
-	cc -o dumpOSC dumpOSC.c
-	
Index: send+dump/sendOSC.c
===================================================================
RCS file: /home/nicb/projects/repositories/OSC-Kit/send+dump/sendOSC.c,v
retrieving revision 1.0.0.1
retrieving revision 1.1
diff -B -b -u -r1.0.0.1 -r1.1
--- send+dump/sendOSC.c	2000/04/23 08:18:22	1.0.0.1
+++ send+dump/sendOSC.c	2000/04/23 08:43:10	1.1
@@ -50,7 +50,9 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <bstring.h>
+#if !defined(HAS_NO_BSTRING_H)
+#	include <bstring.h>
+#endif /* !defined(HAS_NO_BSTRING_H) */
 #include <string.h>
 
 
