Only in C:\icsound\externals\pyext: .cvsignore
diff -wcbB C:\icsound\externals\pyext\csoundmodule.c C:\My_Docs\Visual_C\CsoundAV\py\csoundmodule.c
*** C:\icsound\externals\pyext\csoundmodule.c	Wed Apr 17 20:51:14 2002
--- C:\My_Docs\Visual_C\CsoundAV\py\csoundmodule.c	Wed Apr 17 17:55:04 2002
***************
*** 1,5 ****
  /*
!  * csoundmodule.c
   *
   * Copyright (C) 2002 Maurizio Umberto Puxeddu
   *
--- 1,5 ----
  /*
!   * csoundapi.h
    *
    * Copyright (C) 2002 Maurizio Umberto Puxeddu
    *
***************
*** 17,34 ****
   * License along with this software; if not, write to the Free Software
   * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
   */
! 
! // XXX: memory leaks on event creation abortion
! 
  #include <Python.h>
  #define FUCK_YOU_AND_YOUR_FUCKING_MACROS
  #include "cs.h"
  #include "schedule.h"
  
! #include <csound/ftable.h>
! 
! extern GLOBALS glob;
! extern OPARMS O;
  
  static PyObject *self = 0;
  
--- 17,29 ----
    * License along with this software; if not, write to the Free Software
    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
! #ifdef EMBEDDED_PYTHON
  #include <Python.h>
  #define FUCK_YOU_AND_YOUR_FUCKING_MACROS
  #include "cs.h"
  #include "schedule.h"
  
! //extern GLOBALS glob;
  
  static PyObject *self = 0;
  
***************
*** 136,145 ****
    0
  };
  
  static PyObject *
  csound_ftable_item(csound_FTableObject *self, int index)
  {
!   FUNC *ftp = csoundFindFtable(self->ftnum);
    
    if (ftp == NULL)
      return NULL;
--- 131,142 ----
    0
  };
  
+ extern FUNC **flist;
+ 
  static PyObject *
  csound_ftable_item(csound_FTableObject *self, int index)
  {
!   FUNC *ftp = flist[self->ftnum];
    
    if (ftp == NULL)
      return NULL;
***************
*** 155,161 ****
  {
    PyObject *l;
    int i, n;
!   FUNC *ftp = csoundFindFtable(self->ftnum);
    
    if (ftp == NULL)
      {
--- 152,158 ----
  {
    PyObject *l;
    int i, n;
!   FUNC *ftp = flist[self->ftnum];
    
    if (ftp == NULL)
      {
***************
*** 192,198 ****
  static int
  csound_ftable_item_assign(csound_FTableObject *self, int index, PyObject *value)
  {
!   FUNC *ftp = csoundFindFtable(self->ftnum);
    
    if (ftp == NULL)
      return 1;
--- 189,195 ----
  static int
  csound_ftable_item_assign(csound_FTableObject *self, int index, PyObject *value)
  {
!   FUNC *ftp = flist[self->ftnum];
    
    if (ftp == NULL)
      return 1;
***************
*** 212,218 ****
  csound_ftable_slice_assign(csound_FTableObject *self, int begin, int end, PyObject *value)
  {
    int i, n;
!   FUNC *ftp = csoundFindFtable(self->ftnum);
    PyObject *s;
  
    if (ftp == NULL)
--- 209,215 ----
  csound_ftable_slice_assign(csound_FTableObject *self, int begin, int end, PyObject *value)
  {
    int i, n;
!   FUNC *ftp = flist[self->ftnum];
    PyObject *s;
  
    if (ftp == NULL)
***************
*** 252,258 ****
  static int
  csound_ftable_length(csound_FTableObject *self)
  {
!   FUNC *ftp = csoundFindFtable(self->ftnum);
  
    if (ftp)
      return ftp->flen;
--- 249,256 ----
  static int
  csound_ftable_length(csound_FTableObject *self)
  {
!   extern FUNC    **flist;
!   FUNC *ftp = flist[self->ftnum];
  
    if (ftp)
      return ftp->flen;
***************
*** 293,304 ****
  
  /* MODULE METHODS */
  
  static PyObject *
  csound_orchestra(PyObject *self, PyObject *args)
  {
    if (!PyArg_ParseTuple(args, ":orchestra"))
      return NULL;
!   return Py_BuildValue("s", glob.orchname);
  }
  
  static PyObject *
--- 291,307 ----
  
  /* MODULE METHODS */
  
+ extern char    *orchname;
+ extern char        *scorename;
+ extern long    kcounter;
+ 
+ 
  static PyObject *
  csound_orchestra(PyObject *self, PyObject *args)
  {
    if (!PyArg_ParseTuple(args, ":orchestra"))
      return NULL;
!   return Py_BuildValue("s", /*glob.*/orchname);
  }
  
  static PyObject *
***************
*** 306,312 ****
  {
    if (!PyArg_ParseTuple(args, ":score"))
      return NULL;
!   return Py_BuildValue("s", glob.scorename);
  }
  
  static PyObject *
--- 309,315 ----
  {
    if (!PyArg_ParseTuple(args, ":score"))
      return NULL;
!   return Py_BuildValue("s", /* glob. */ scorename);
  }
  
  static PyObject *
***************
*** 314,320 ****
  {
    if (!PyArg_ParseTuple(args, ":kcycle"))
      return NULL;
!   return Py_BuildValue("i", glob.kcounter);
  }
  
  static PyObject *
--- 317,323 ----
  {
    if (!PyArg_ParseTuple(args, ":kcycle"))
      return NULL;
!   return Py_BuildValue("i", /* glob. */ kcounter);
  }
  
  static PyObject *
***************
*** 322,328 ****
  {
    if (!PyArg_ParseTuple(args, ":time"))
      return NULL;
!   return Py_BuildValue("f", glob.kcounter * glob.onedkr);
  }
  
  #define FZERO (FL(0.0))    /* (Shouldn't there be global decl's for these?) */
--- 325,331 ----
  {
    if (!PyArg_ParseTuple(args, ":time"))
      return NULL;
!   return Py_BuildValue("f", /* glob. */ kcounter * /* glob. */ onedkr);
  }
  
  #define FZERO (FL(0.0))    /* (Shouldn't there be global decl's for these?) */
***************
*** 355,381 ****
    }
  
    /* Add current time (see note about kadjust in triginset() above) */
!   newnode->kstart = (long)(starttime * glob.ekr + FL(0.5));
    newevt->p2orig = starttime;
    newevt->p3orig = dur;
    /* Copy all arguments to the new event */
    newevt->pcnt = narg;
    for (i = 0; i < narg-3; i++)
- 	{
  	  newevt->p[i+4] = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, i + 3));
- 	  if (PyErr_Occurred()) return NULL;
- 	}
    newevt->p[3] = dur;
    newevt->p[2] = starttime;    /* Set actual start time in p2 */
    newevt->p[1] = (MYFLT)(newnode->insno = insno);
  
!   queue_event_node(newnode);
  
    Py_INCREF(Py_None);
    return Py_None;
- 
-  failure:
- 
  }
  
  static PyObject *
--- 358,388 ----
    }
  
    /* Add current time (see note about kadjust in triginset() above) */
!   newnode->kstart = (long)(starttime * /* glob. */ ekr + FL(0.5));
    newevt->p2orig = starttime;
    newevt->p3orig = dur;
    /* Copy all arguments to the new event */
    newevt->pcnt = narg;
    for (i = 0; i < narg-3; i++)
      newevt->p[i+4] = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, i + 3));
    newevt->p[3] = dur;
    newevt->p[2] = starttime;    /* Set actual start time in p2 */
    newevt->p[1] = (MYFLT)(newnode->insno = insno);
  
!   /* Insert eventnode in list of generated events */
!   evtlist = &/* glob. */ OrcTrigEvts;
!   while (evtlist->nxtevt) {
!     if (newnode->kstart < evtlist->nxtevt->kstart) break;
!     evtlist = evtlist->nxtevt;
!   }
!   newnode->nxtevt = evtlist->nxtevt;
!   evtlist->nxtevt = newnode;
!   O.RTevents = 1;     /* Make sure kperf() looks for RT events */
!   O.ksensing = 1;
!   O.OrcEvts  = 1;     /* - of the appropriate type */
    
    Py_INCREF(Py_None);
    return Py_None;
  }
  
  static PyObject *
***************
*** 391,397 ****
      return NULL;
  
    onset = PyFloat_AsDouble(PyTuple_GET_ITEM(args, 0));
-   if (PyErr_Occurred()) return NULL;
  
    newnode = (EVTNODE *) mmalloc((long)sizeof(EVTNODE));
    newevt = &newnode->evt;
--- 398,403 ----
***************
*** 404,416 ****
    }
  
    /* Add current time (see note about kadjust in triginset() above) */
!   newnode->kstart = (long)(starttime * glob.ekr + FL(0.5));
    newevt->p2orig = starttime;
    newevt->p3orig = dur;
    /* Copy all arguments to the new event */
    newevt->pcnt = 1;
  
!   queue_event_node(newnode);
    
    Py_INCREF(Py_None);
    return Py_None;
--- 410,432 ----
    }
  
    /* Add current time (see note about kadjust in triginset() above) */
!   newnode->kstart = (long)(starttime * /* glob. */ ekr + FL(0.5));
    newevt->p2orig = starttime;
    newevt->p3orig = dur;
    /* Copy all arguments to the new event */
    newevt->pcnt = 1;
  
!   /* Insert eventnode in list of generated events */
!   evtlist = &/* glob. */ OrcTrigEvts;
!   while (evtlist->nxtevt) {
!     if (newnode->kstart < evtlist->nxtevt->kstart) break;
!     evtlist = evtlist->nxtevt;
!   }
!   newnode->nxtevt = evtlist->nxtevt;
!   evtlist->nxtevt = newnode;
!   O.RTevents = 1;     /* Make sure kperf() looks for RT events */
!   O.ksensing = 1;
!   O.OrcEvts  = 1;     /* - of the appropriate type */
    
    Py_INCREF(Py_None);
    return Py_None;
***************
*** 434,460 ****
      }
  
    what = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, 0));
-   if (PyErr_Occurred()) return NULL;
    size = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, 1));
-   if (PyErr_Occurred()) return NULL;
    fgen = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, 2));
-   if (PyErr_Occurred()) return NULL;
  
    newevt.opcod = 'f';
    /* Set start time from kwhen */
    starttime = FZERO;
  
    /* Add current time (see note about kadjust in triginset() above) */
!   newevt.pcnt = (short)(starttime * glob.ekr + FL(0.5));
    newevt.p2orig = starttime;
    newevt.p3orig = size;
    /* Copy all arguments to the new event */
    newevt.pcnt = narg + 2;
    for (i = 0; i < narg-3; i++)
- 	{
  	  newevt.p[i+5] = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, i + 3));
- 	  if (PyErr_Occurred()) return NULL;
- 	}
    newevt.p[4] = (short)fgen;
    newevt.p[3] = (int)size;
    newevt.p[2] = starttime;    /* Set actual start time in p2 */
--- 450,470 ----
      }
  
    what = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, 0));
    size = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, 1));
    fgen = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, 2));
  
    newevt.opcod = 'f';
    /* Set start time from kwhen */
    starttime = FZERO;
  
    /* Add current time (see note about kadjust in triginset() above) */
!   newevt.pcnt = (short)(starttime * /* glob. */ ekr + FL(0.5));
    newevt.p2orig = starttime;
    newevt.p3orig = size;
    /* Copy all arguments to the new event */
    newevt.pcnt = narg + 2;
    for (i = 0; i < narg-3; i++)
      newevt.p[i+5] = (MYFLT)PyFloat_AsDouble(PyTuple_GET_ITEM(args, i + 3));
    newevt.p[4] = (short)fgen;
    newevt.p[3] = (int)size;
    newevt.p[2] = starttime;    /* Set actual start time in p2 */
***************
*** 528,530 ****
--- 538,541 ----
  {
    return self;
  }
+ #endif
\ No newline at end of file
Only in C:\My_Docs\Visual_C\CsoundAV\py: csoundmodule.c~
Only in C:\icsound\externals\pyext: CVS
Only in C:\icsound\externals\pyext: doc
diff -wcbB C:\icsound\externals\pyext\embeddedpython.c C:\My_Docs\Visual_C\CsoundAV\py\embeddedpython.c
*** C:\icsound\externals\pyext\embeddedpython.c	Thu Apr 18 01:27:28 2002
--- C:\My_Docs\Visual_C\CsoundAV\py\embeddedpython.c	Wed Apr 17 17:55:04 2002
***************
*** 17,51 ****
   * License along with this software; if not, write to the Free Software
   * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
! 
  #include <stdio.h>
  #include <Python.h>
! #include "embeddedpython.h"
! #include "csoundmodule.h"
  
  void
! python_startup(int argc0, char *argv0[])
  {
!   static char *argv[] = {"pyext"};
!   static char *startup_script =
! 	"import sys\n"
! 	"version = sys.version.split(' ')[0]\n"
! 	"print 'Embedded Python interpreter version %s' % version\n"
! 	"sys.path.append('.')\n"
! 	"sys.path.append('/usr/local/csound/externals')\n"
! 	"del version\n"
!  	"del sys\n"
! 	"import csound\n";
!   
!   Py_SetProgramName("pyext");
    Py_Initialize();
    
!   PySys_SetArgv(1, argv);
    
    csound_module_init();
  
    PyRun_SimpleString("\n");
!   PyRun_SimpleString(startup_script);
  }
  
  void
--- 17,54 ----
    * License along with this software; if not, write to the Free Software
    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
! #ifdef EMBEDDED_PYTHON
  #include <stdio.h>
  #include <Python.h>
! #include "py/embeddedpython.h"
! #include "py/csoundmodule.h"
  
  void
! python_startup(int argc, char *argv[])
  {
!   Py_SetProgramName(argv[0]);
    Py_Initialize();
    
!   PySys_SetArgv(argc, argv);
  
    csound_module_init();
  
+   python_print_version();
+   PyRun_SimpleString("import csound");
+ }
+ 
+ void
+ python_print_version(void)
+ {
+   // This first one should fail. Don't know why yet.
    PyRun_SimpleString("\n");
!   
!   PyRun_SimpleString("import sys");
!   PyRun_SimpleString("version = sys.version.split(' ')[0]");
!   PyRun_SimpleString("print 'Embedded Python interpreter version %s' % version");
!   PyRun_SimpleString("sys.path.append('.')");
!   PyRun_SimpleString("del version");
!   PyRun_SimpleString("del sys");
  }
  
  void
***************
*** 138,140 ****
--- 141,144 ----
  {
    return stderrWriteCallback(data, size);
  }
+ #endif
\ No newline at end of file
Only in C:\icsound\externals\pyext: Makefile
Only in C:\My_Docs\Visual_C\CsoundAV\py: py.diff
Only in C:\My_Docs\Visual_C\CsoundAV\py: pycall.c.auto
Only in C:\My_Docs\Visual_C\CsoundAV\py: pycall.h.auto
Only in C:\icsound\externals\pyext: pyext.c
Only in C:\icsound\externals\pyext: pyextlib
diff -wcbB C:\icsound\externals\pyext\pythonhelper.h C:\My_Docs\Visual_C\CsoundAV\py\pythonhelper.h
*** C:\icsound\externals\pyext\pythonhelper.h	Tue Apr 16 07:20:44 2002
--- C:\My_Docs\Visual_C\CsoundAV\py\pythonhelper.h	Mon Apr 08 17:54:32 2002
***************
*** 23,32 ****
  
  #include <Python.h>
  
! //#define GETPYLOCAL(ids) ((PyObject *)ids->pylocal)
! //#define SETPYLOCAL(ids, p) { ids->pylocal = (void *)p; }
  
! #define GETPYLOCAL(ids) ((PyObject *)csoundGetAttachment(ids, pythonAttachmentType))
! #define SETPYLOCAL(ids, p) csoundSetAttachment(ids, pythonAttachmentType, p);
  
  #endif
--- 23,33 ----
  
  #include <Python.h>
  
! /*
!   I do it because I can't #include <Python.h> in "cs.h".
!  */
  
! #define GETPYLOCAL(ids) ((PyObject *)ids->pylocal)
! #define SETPYLOCAL(ids, p) { ids->pylocal = (void *)p; }
  
  #endif
diff -wcbB C:\icsound\externals\pyext\pythonopcodes.c C:\My_Docs\Visual_C\CsoundAV\py\pythonopcodes.c
*** C:\icsound\externals\pyext\pythonopcodes.c	Tue Apr 16 07:20:44 2002
--- C:\My_Docs\Visual_C\CsoundAV\py\pythonopcodes.c	Tue Apr 09 11:31:38 2002
***************
*** 17,35 ****
   * License along with this software; if not, write to the Free Software
   * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
   */
  
  #include <Python.h>
! #include "pythonopcodes.h"
! #include "pythonhelper.h"
! 
! // Attachment type number
! static int pythonAttachmentType = -1;
! 
! void
! python_set_attachment_type_number(int n)
! {
!   pythonAttachmentType = n;
! }
  
  /* HELPERS */
  
--- 17,27 ----
    * License along with this software; if not, write to the Free Software
    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
+ #ifdef EMBEDDED_PYTHON
  
  #include <Python.h>
! #include "py/pythonopcodes.h"
! #include "py/pythonhelper.h"
  
  /* HELPERS */
  
***************
*** 217,219 ****
--- 209,212 ----
      }
  }
  
+ #endif // EMBEDDED_PYTHON
diff -wcbB C:\icsound\externals\pyext\pythonopcodes.h C:\My_Docs\Visual_C\CsoundAV\py\pythonopcodes.h
*** C:\icsound\externals\pyext\pythonopcodes.h	Tue Apr 16 07:20:44 2002
--- C:\My_Docs\Visual_C\CsoundAV\py\pythonopcodes.h	Mon Apr 08 17:54:32 2002
***************
*** 24,31 ****
  #include <Python.h>
  #include "cs.h"
  
! #include "pyx.h.auto"
! #include "pycall.h.auto"
  
  typedef struct {
    OPDS h;
--- 24,31 ----
  #include <Python.h>
  #include "cs.h"
  
! #include "py/pyx.h.auto"
! #include "py/pycall.h.auto"
  
  typedef struct {
    OPDS h;
***************
*** 39,45 ****
  extern void pylcalln_irate(PYCALLN *p);
  extern void pylcalln_krate(PYCALLN *p);
  extern void pylcallni_irate(PYCALLN *p);
- 
- extern void python_set_attachment_type_number(int n);
  
  #endif /* _pycsound_pythonopcodes_h_ */
--- 39,43 ----
Only in C:\My_Docs\Visual_C\CsoundAV\py: pyx-gen.py~
Only in C:\My_Docs\Visual_C\CsoundAV\py: pyx.c.auto
Only in C:\My_Docs\Visual_C\CsoundAV\py: pyx.h.auto
Only in C:\icsound\externals\pyext: TODO
