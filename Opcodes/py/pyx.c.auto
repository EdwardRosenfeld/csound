int
pyexec_krate(PYEXEC *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyexec_krate: a string is needed");
      return NOTOK;
    }

  strcpy(source, unquote(p->STRARG));

  result = exec_file_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyexec_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyexeci_irate(PYEXEC *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyexeci_irate: a string is needed");
      return NOTOK;
    }

  strcpy(source, unquote(p->STRARG));

  result = exec_file_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyexeci_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylexec_irate(PYEXEC *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylexec_krate(PYEXEC *p)
{
  char source[1024];
  PyObject *result;

  strcpy(source, unquote(p->STRARG));

  result = exec_file_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylexec_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylexeci_irate(PYEXEC *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pylexeci_irate: a string is needed");
      return NOTOK;
    }

  create_private_namespace_if_needed(&p->h);

  strcpy(source, unquote(p->STRARG));

  result = exec_file_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylexeci_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyexect_krate(PYEXECT *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyexect_krate: a string is needed");
      return NOTOK;
    }

  if (!*p->trigger) return OK;

  strcpy(source, unquote(p->STRARG));

  result = exec_file_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyexec_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylexect_irate(PYEXECT *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylexect_krate(PYEXECT *p)
{
  char source[1024];
  PyObject *result;

  if (!*p->trigger) return OK;

  strcpy(source, unquote(p->STRARG));

  result = exec_file_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylexec_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyrun_krate(PYRUN *p)
{
  char source[40960];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyrun_krate: a string is needed");
      return NOTOK;
    }

  strcpy(source, unquote(p->STRARG));

  result = run_statement_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyrun_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyruni_irate(PYRUN *p)
{
  char source[40960];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyruni_irate: a string is needed");
      return NOTOK;
    }

  strcpy(source, unquote(p->STRARG));

  result = run_statement_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyruni_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylrun_irate(PYRUN *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylrun_krate(PYRUN *p)
{
  char source[40960];
  PyObject *result;

  strcpy(source, unquote(p->STRARG));

  result = run_statement_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylrun_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylruni_irate(PYRUN *p)
{
  char source[40960];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pylruni_irate: a string is needed");
      return NOTOK;
    }

  create_private_namespace_if_needed(&p->h);

  strcpy(source, unquote(p->STRARG));

  result = run_statement_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylruni_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyrunt_krate(PYRUNT *p)
{
  char source[40960];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyrunt_krate: a string is needed");
      return NOTOK;
    }

  if (!*p->trigger) return OK;

  strcpy(source, unquote(p->STRARG));

  result = run_statement_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyrun_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylrunt_irate(PYRUNT *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylrunt_krate(PYRUNT *p)
{
  char source[40960];
  PyObject *result;

  if (!*p->trigger) return OK;

  strcpy(source, unquote(p->STRARG));

  result = run_statement_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylrun_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyeval_krate(PYEVAL *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyeval_krate: a string is needed");
      return NOTOK;
    }

  strcpy(source, unquote(p->STRARG));

  result = eval_string_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyeval_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  else if (!PyFloat_Check(result))
    {
      err_printf("pyeval_krate: expression must evaluate in a float\n");
    }
  else
    {
       *p->result = PyFloat_AsDouble(result);
    }
  Py_DECREF(result);
  return OK;
}

int
pyevali_irate(PYEVAL *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyevali_irate: a string is needed");
      return NOTOK;
    }

  strcpy(source, unquote(p->STRARG));

  result = eval_string_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyevali_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  else if (!PyFloat_Check(result))
    {
      err_printf("pyevali_irate: expression must evaluate in a float\n");
    }
  else
    {
       *p->result = PyFloat_AsDouble(result);
    }
  Py_DECREF(result);
  return OK;
}

int
pyleval_irate(PYEVAL *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pyleval_krate(PYEVAL *p)
{
  char source[1024];
  PyObject *result;

  strcpy(source, unquote(p->STRARG));

  result = eval_string_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pyleval_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  else if (!PyFloat_Check(result))
    {
      err_printf("pyleval_krate: expression must evaluate in a float\n");
    }
  else
    {
       *p->result = PyFloat_AsDouble(result);
    }
  Py_DECREF(result);
  return OK;
}

int
pylevali_irate(PYEVAL *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pylevali_irate: a string is needed");
      return NOTOK;
    }

  create_private_namespace_if_needed(&p->h);

  strcpy(source, unquote(p->STRARG));

  result = eval_string_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylevali_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  else if (!PyFloat_Check(result))
    {
      err_printf("pylevali_irate: expression must evaluate in a float\n");
    }
  else
    {
       *p->result = PyFloat_AsDouble(result);
    }
  Py_DECREF(result);
  return OK;
}

int
pyevalt_krate(PYEVALT *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyevalt_krate: a string is needed");
      return NOTOK;
    }

  if (!*p->trigger)
    {
      *p->result = p->oresult;
    }

  strcpy(source, unquote(p->STRARG));

  result = eval_string_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyeval_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  else if (!PyFloat_Check(result))
    {
      err_printf("pyeval_krate: expression must evaluate in a float\n");
    }
  else
    {
       *p->result = PyFloat_AsDouble(result);
       p->oresult = *p->result;
    }
  Py_DECREF(result);
  return OK;
}

int
pylevalt_irate(PYEVALT *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylevalt_krate(PYEVALT *p)
{
  char source[1024];
  PyObject *result;

  if (!*p->trigger)
    {
      *p->result = p->oresult;
    }

  strcpy(source, unquote(p->STRARG));

  result = eval_string_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pyleval_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  else if (!PyFloat_Check(result))
    {
      err_printf("pyleval_krate: expression must evaluate in a float\n");
    }
  else
    {
       *p->result = PyFloat_AsDouble(result);
       p->oresult = *p->result;
    }
  Py_DECREF(result);
  return OK;
}

int
pyassign_krate(PYASSIGN *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyassign_krate: a string is needed");
      return NOTOK;
    }

  sprintf(source, "%s = %f", unquote(p->STRARG), *p->value);

  result = run_statement_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyassign_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyassigni_irate(PYASSIGN *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyassigni_irate: a string is needed");
      return NOTOK;
    }

  sprintf(source, "%s = %f", unquote(p->STRARG), *p->value);

  result = run_statement_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyassigni_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylassign_irate(PYASSIGN *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylassign_krate(PYASSIGN *p)
{
  char source[1024];
  PyObject *result;

  sprintf(source, "%s = %f", unquote(p->STRARG), *p->value);

  result = run_statement_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylassign_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylassigni_irate(PYASSIGN *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pylassigni_irate: a string is needed");
      return NOTOK;
    }

  create_private_namespace_if_needed(&p->h);

  sprintf(source, "%s = %f", unquote(p->STRARG), *p->value);

  result = run_statement_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylassigni_irate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pyassignt_krate(PYASSIGNT *p)
{
  char source[1024];
  PyObject *result;

  if (*p->string != sstrcod)
    {
      err_printf("pyassignt_krate: a string is needed");
      return NOTOK;
    }

  if (!*p->trigger) return OK;

  sprintf(source, "%s = %f", unquote(p->STRARG), *p->value);

  result = run_statement_in_given_context(source, 0);
  if (result == NULL)
    {
      err_printf("pyassign_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

int
pylassignt_irate(PYASSIGNT *p)
{
  if (*p->string != sstrcod)
    return NOTOK;

  create_private_namespace_if_needed(&p->h);
  return OK;
}

int
pylassignt_krate(PYASSIGNT *p)
{
  char source[1024];
  PyObject *result;

  if (!*p->trigger) return OK;

  sprintf(source, "%s = %f", unquote(p->STRARG), *p->value);

  result = run_statement_in_given_context(source, GETPYLOCAL(p->h.insdshead));
  if (result == NULL)
    {
      err_printf("pylassign_krate: python exception\n");
      PyErr_Print();
      return NOTOK;
    }
  Py_DECREF(result);
  return OK;
}

