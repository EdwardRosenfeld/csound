#J vim: filetype=python expandtab sw=4 tabstop=4
# Copied from SConstruct revision 1.646
print '''
C S O U N D 5

SCons build file for Csound 5:
API library, plugin opcodes, utilities, and front ends.

By Michael Gogins <gogins at pipeline dot com>

For custom options, run 'scons -h'.
For default options, run 'scons -H'.
If headers or libraries are not found, edit 'custom.py'.
For Linux, run in the standard shell
    with standard Python and just run 'scons'.
For MinGW, run in the MSys shell
    and use www.python.org WIN32 Python to run scons.
For Microsoft Visual C++, run in the Platform SDK
    command shell, and use www.python.org WIN32 Python to run scons.
'''

import time
import glob
import os
import os.path
import sys
import string
import shutil
import copy

#############################################################################
#
#   UTILITY FUNCTIONS
#############################################################################

# This class contains all utility functions that are needed.
class Utility:

    def __init__(self):
        if sys.platform[:5] == 'linux'      : self.platform = 'linux'
        elif sys.platform[:3] == 'win'      : self.platform = 'win32'
        elif sys.platform[:6] == 'darwin'   : self.platform = 'darwin'
        else                                : self.platform = 'unsupported'

    def compilerIntel(self):
        if self.platform == 'win32' and initialEnvironment['withICL'] == '1':
            return True
        else:
            return False

    def compilerMicrosoft(self):
        if self.platform == 'win32' and initialEnvironment['withMSVC'] == '1':
            return True
        else:
            return False

    def compilerGNU(self):
        if not self.compilerIntel() and not self.compilerMicrosoft():
            return True
        else:
            return False

    def MacOSX_InstallHeader(self, headerName):
        if not buildOSXFramework:
            return
        baseName = headerName[(headerName.rfind('/') + 1):]
        targetName = '%s/Headers/%s' % (OSXFrameworkCurrentVersion, baseName)
        cmd = 'cp -f %s %s' % (headerName, targetName)
        csoundFrameworkEnvironment.Command(targetName, headerName, cmd)

    def MacOSX_InstallPlugin(self, fileName):
        if buildOSXFramework:
            pluginDir = '%s/Resources/Opcodes' % OSXFrameworkCurrentVersion
            if initialEnvironment['useDouble'] != '0':
                pluginDir += '64'
            cmd = 'cp -f %s %s/' % (fileName, pluginDir)
            csoundFrameworkEnvironment.Command('%s/%s' % (pluginDir, fileName),
                    fileName, cmd)

    def makePlugin(self, env, pluginName, srcs):
        pluginLib = env.SharedLibrary(pluginName, srcs)
        pluginLibraries.append(pluginLib)
        self.MacOSX_InstallPlugin('lib' + pluginName + '.dylib')
        return pluginLib

    def fixCFlagsForSwig(self, env):
        if '-pedantic' in env['CCFLAGS']:
            env['CCFLAGS'].remove('-pedantic')
        if '-pedantic' in env['CXXFLAGS']:
            env['CXXFLAGS'].remove('-pedantic')
        if self.compilerGNU():
            # work around non-ANSI type punning in SWIG generated wrapper files
            env['CCFLAGS'].append('-fno-strict-aliasing')
            env['CXXFLAGS'].append('-fno-strict-aliasing')

    def makePythonModule(self, env, targetName, srcs):
        if self.platform == 'darwin':
            env.Prepend(LINKFLAGS = ['-bundle'])
            pyModule_ = env.Program('_%s.so' % targetName, srcs)
        else:
            if self.platform == 'linux':
                pyModule_ = env.SharedLibrary('%s' % targetName, srcs,
                        SHLIBPREFIX="_", SHLIBSUFFIX = '.so')
            else:
                pyModule_ = env.SharedLibrary('_%s' % targetName,
                        srcs, SHLIBSUFFIX = '.pyd')
            if self.platform == 'win32' and \
             initialEnvironment['pythonVersion'] < '2.4':
                    Depends(pyModule_, pythonImportLibrary)
            print "PYTHON MODULE %s..." % targetName
        pythonModules.append(pyModule_)
        pythonModules.append('%s.py' % targetName)
        return pyModule_

    def addOSXResourceFork(self, env, baseName, dirName):
        if self.platform == 'darwin':
            if dirName != ''    : fileName = dirName + '/' + baseName
            else                : fileName = baseName
            env.Command(('%s/resources' % fileName).replace('/', '_'), fileName,
                        "/Developer/Tools/Rez -i APPL -o $SOURCE cs5.r")

    def fluidTarget(self, env, dirName, baseName, objFiles, dir = None):
        flFile = dirName + '/' + baseName + '.fl'
        cppFile = dirName + '/' + baseName + '.cpp'
        hppFile = dirName + '/' + baseName + '.hpp'
        if dir != None:
            env.Command([cppFile, hppFile], flFile,
                        'fluid -c -o %s/%s -h %s/%s %s/%s' % 
                        (dir, cppFile, dir, hppFile, dir, flFile))
        else:
            env.Command([cppFile, hppFile], flFile,
                    'fluid -c -o %s -h %s %s' % (cppFile, hppFile, flFile))
        for i in objFiles:
            Depends(i, cppFile)
        return cppFile

    def gettextTarget(self, env, baseName, target):
        gtFile = 'po/' + baseName + '.po'
        ttFile = 'po/' + target + '/LC_MESSAGES/csound5.mo'
        env.Command(ttFile, gtFile, 'msgfmt -o %s %s' % (ttFile, gtFile))
        return ttFile
    # Output stuff
    def confDecision(self, msg):
        print "CONFIGURATION DECISION: " + msg
    def fatal(self, msg):
        print >> sys.stderr, "FATAL: " + msg
        Exit(1)

    def fixEnvForOLPC(self, env):
        if env['buildOLPC'] == '1':
            env['pythonVersion']    = '2.5'
            env.Prepend(CPPFLAGS    = ['-DOLPC'])
            env.Prepend(CPPFLAGS    = ['-DENABLE_OPCODEDIR_WARNINGS=0'])

            if util.getPlatform() != 'linux': print "Build platform is not linux"
            # Set other options??
            env['useGettext']           = '1'
            env['useDouble']            = '0'
            env['usePortAudio']         = '0'
            env['useJack']              = '0'
            env['buildCsoundAC']        = '0'
            env['buildCsound5GUI']      = '0'
            env['useDouble']            = '0'
            env['usePortMIDI']          = '0'
            env['useALSA']              = '1'
            env['useFLTK']              = '0'
            env['buildCsoundVST']       = '0'
            env['buildCsoundAC']        = '0'
            #'buildCsound5GUI'
            env['buildLoris']           = '0'
            env['buildStkOpcodes']      = '0'
            env['useOSC']               = '1'
            env['buildFluidOpcodes']    = '0'
            env['prefix']               = '/usr'
            env['buildUtilities']       = '0'
            ##env['gcc4opt']            = '1'
            env['useLrint']             = '1'
            env['Word64']               = '0'
            env['Lib64']                = '0'
            env['buildPDClass']         = '0'
            env['buildDSSI']            = '0'
            env['buildVirtual']         = '1'
            env['buildInterfaces']      = '1'
            env['buildSDFT']            = '0'
            env['buildJavaWrapper']     = '0'
            env['buildNewParser']       = '0'
            env['buildvst4cs']          = '0'
            env['buildImageOpcodes']    = '1'
            env['dynamicCsoundLibrary'] = '1'


util = Utility()

pluginLibraries = []
executables     = []
libs            = []
pythonModules   = []
headers = Split('''
    H/cfgvar.h H/cscore.h H/csdl.h H/csound.h H/csound.hpp H/csoundCore.h
    H/cwindow.h H/msg_attr.h H/OpcodeBase.hpp H/pstream.h H/pvfileio.h
    H/soundio.h H/sysdep.h H/text.h H/version.h
    interfaces/CsoundFile.hpp interfaces/CppSound.hpp interfaces/filebuilding.h
''')

#############################################################################
#
#   DEFINE CONFIGURATION
#
#############################################################################

print "System platform is '" + util.platform + "'."

# Create options that can be set from the command line.

commandOptions = Options()
commandOptions.Add('CC')
commandOptions.Add('CXX')
commandOptions.Add('LINK')
commandOptions.Add('LINKFLAGS')
commandOptions.Add('custom',
    'Specify name of custom options file (default is "custom.py")',
    'custom.py')
commandOptions.Add('useDouble',
    'Set to 1 to use double-precision floating point for audio samples.',
    '0')
commandOptions.Add('usePortAudio',
    'Set to 1 to use PortAudio for real-time audio input and output.',
    '1')
commandOptions.Add('usePortMIDI',
    'Build PortMidi plugin for real time MIDI input and output.',
    '1')
commandOptions.Add('useALSA',
    'Set to 1 to use ALSA for real-time audio and MIDI input and output.',
    '1')
commandOptions.Add('useJack',
    'Set to 1 if you compiled PortAudio to use Jack; also builds Jack plugin.',
    '1')
commandOptions.Add('pythonVersion',
    'Set to the Python version to be used.',
    '%d.%d' % (int(sys.hexversion) >> 24, (int(sys.hexversion) >> 16) & 255))
commandOptions.Add('buildCsoundVST',
    'Set to 1 to build CsoundVST (needs CsoundAC, FLTK, boost, Python, SWIG).',
    '0')
commandOptions.Add('buildCsoundAC',
    'Set to 1 to build CsoundAC (needs FLTK, boost, Python, SWIG).',
    '0')
commandOptions.Add('generateTags',
    'Set to 1 to generate TAGS',
    '0')
commandOptions.Add('generatePdf',
    'Set to 1 to generate PDF documentation',
    '0')
commandOptions.Add('buildLoris',
    'Set to 1 to build the Loris Python extension and opcodes',
    '1')
commandOptions.Add('buildPythonOpcodes',
    'Set to 1 to build Python opcodes',
    '0')
commandOptions.Add('prefix',
    'Base directory for installs. Defaults to /usr/local.',
    '/usr/local')
commandOptions.Add('buildRelease',
    'Set to 1 to build for release (implies noDebug).',
    '0')
commandOptions.Add('noDebug',
    'Build without debugging information.',
    '0')
commandOptions.Add('gcc3opt',
    'Enable gcc 3.3.x or later optimizations for a specific CPU architecture (e.g. pentium3); implies noDebug.',
    '0')
commandOptions.Add('gcc4opt',
    'Enable gcc 4.0 or later optimizations for a specific CPU architecture (e.g. pentium3); implies noDebug.',
    '0')
commandOptions.Add('useLrint',
    'Use lrint() and lrintf() for converting floating point values to integers.',
    '0')
commandOptions.Add('useGprof',
    'Build with profiling information (-pg).',
    '0')
commandOptions.Add('Word64',
    'Build for 64bit computer',
    '0')
commandOptions.Add('Lib64',
    'Build for lib64 rather than lib',
    '0')
if util.platform == 'win32':
    commandOptions.Add('dynamicCsoundLibrary',
        'Set to 0 to build static Csound library instead of csound.dll',
        '1')
else:
    commandOptions.Add('dynamicCsoundLibrary',
        'Build dynamic Csound library instead of libcsound.a',
        '0')
commandOptions.Add('buildStkOpcodes',
    "Build opcodes encapsulating Perry Cook's Synthesis Toolkit in C++ instruments and effects",
    '0')
commandOptions.Add('install',
    'Enables the Install targets',
    '0')
commandOptions.Add('useCoreAudio',
    "Set to 1 to use CoreAudio for real-time audio input and output.",
    '1')
commandOptions.Add('useAltivec',
    "On OSX use the gcc AltiVec optmisation flags",
    '0')
commandOptions.Add('buildDSSI',
    "Build DSSI/LADSPA host opcodes",
    '1')
commandOptions.Add('buildUtilities',
    "Build stand-alone executables for utilities that can also be used with -U",
    '1')
commandOptions.Add('buildTclcsound',
    "Build Tclcsound frontend (cstclsh, cswish and tclcsound dynamic module). Requires Tcl/Tk headers and libs",
    '0')
commandOptions.Add('buildInterfaces',
    "Build interface library for Python, JAVA, Lua, C++, and other languages.",
    '0')
commandOptions.Add('buildJavaWrapper',
    'Set to 1 to build Java wrapper for the interface library.',
    '0')
commandOptions.Add('withICL',
    'On Windows, set to 1 to build with the Intel C++ Compiler (also requires Microsoft Visual C++), or set to 0 to build with MinGW',
    '0')
commandOptions.Add('withMSVC',
    'On Windows, set to 1 to build with Microsoft Visual C++, or set to 0 to build with MinGW',
    '0')
commandOptions.Add('buildNewParser',
    'Enable building new parser (requires Flex/Bison)',
    '0')
commandOptions.Add('buildvst4cs',
    'Set to 1 to build vst4cs plugins (requires Steinberg VST headers)',
    '0')
commandOptions.Add('buildSDFT',
    'Set to 0 to avoid building SDFT code',
    '1')
commandOptions.Add('useGettext',
    'Set to 1 to use the GBU internationalisation/localisation scheme)',
    '0')
##### JPff for OLPC #####
commandOptions.Add('buildOLPC',
    'Set to 1 to build OLPC version',
    '0')

# Define the common part of the build environment.
# This section also sets up customized options for third-party libraries, which
# should take priority over default options.

initialEnvironment = Environment(ENV = {'PATH' : os.environ['PATH']})
commandOptions.Update(initialEnvironment)

optionsFilename = 'custom.py'

if util.compilerIntel():
    print 'Importing complete environment for the Intel C++ Compiler (ICL)...'
    initialEnvironment = Environment(ENV = os.environ)
    commandOptions.Update(initialEnvironment)
    Tool('icl')(initialEnvironment)
    optionsFilename = 'custom-msvc.py'
elif util.compilerMicrosoft():
    # To enable the Microsoft tools, 
    # the WHOLE environment must be imported,
    # not just the PATH; so we replace the 
    # enviroment with a more complete one.
    print 'Importing complete environment for Microsoft Visual C++ (MSVC)...'
    initialEnvironment = Environment(ENV = os.environ)
    commandOptions.Update(initialEnvironment)
    optionsFilename = 'custom-msvc.py'
elif util.platform == 'win32':
    # Similarly, on Windows, to exclude MSVC tools,
    # we have to force MinGW tools and then re-create
    # the environment from scratch.
    initialEnvironment = Environment(ENV = os.environ, tools = ['mingw', 'swig', 'javac', 'jar'])
    commandOptions.Update(initialEnvironment)
    #Tool('mingw')(initialEnvironment)
    optionsFilename = 'custom-mingw.py'

Help(commandOptions.GenerateHelpText(initialEnvironment))

if initialEnvironment['custom']:
    optionsFilename = initialEnvironment['custom']

print "Using options from '%s.'" % optionsFilename

fileOptions = Options(optionsFilename)
fileOptions.Add('customCPPPATH', 'List of custom CPPPATH variables')
fileOptions.Add('customCCFLAGS')
fileOptions.Add('customCXXFLAGS')
fileOptions.Add('customLIBS')
fileOptions.Add('customLIBPATH')
fileOptions.Add('customSHLINKFLAGS')
fileOptions.Add('customSWIGFLAGS')
fileOptions.Update(initialEnvironment)

customCPPPATH       = initialEnvironment['customCPPPATH']
initialEnvironment.Prepend(CPPPATH = customCPPPATH)
customCCFLAGS       = initialEnvironment['customCCFLAGS']
initialEnvironment.Prepend(CCFLAGS = customCCFLAGS)
customCXXFLAGS      = initialEnvironment['customCXXFLAGS']
initialEnvironment.Prepend(CXXFLAGS = customCXXFLAGS)
customLIBS          = initialEnvironment['customLIBS']
initialEnvironment.Prepend(LIBS = customLIBS)
customLIBPATH       = initialEnvironment['customLIBPATH']
initialEnvironment.Prepend(LIBPATH = customLIBPATH)
customSHLINKFLAGS   = initialEnvironment['customSHLINKFLAGS']
initialEnvironment.Prepend(SHLINKFLAGS = customSHLINKFLAGS)
customSWIGFLAGS     = initialEnvironment['customSWIGFLAGS']
initialEnvironment.Prepend(SWIGFLAGS = customSWIGFLAGS)

buildOLPC           = ( initialEnvironment['buildOLPC'] == '1')
if buildOLPC:
    jackFound       = False
    fltkFound       = False
    portaudioFound  = False
    oscFound        = True
util.fixEnvForOLPC( initialEnvironment )

# Define options for different platforms.
if util.platform != 'win32':
    print "Build platform is '" + util.platform + "'."
else:
    if util.compilerMicrosoft():
        print "Build platform is Microsoft Visual C++ (MSVC)."
    elif util.compilerIntel():
        print "Build platform is the Intel C++ Compiler (ICL)."
    elif util.compilerGNU():
        print "Build platform is MinGW/MSYS"

print "SCons tools on this platform: ", initialEnvironment['TOOLS']

if util.compilerGNU():
    # Avoid warnings about things we won't fix anyway
    initialEnvironment.Append(CCFLAGS  = '-Wno-write-strings')
    initialEnvironment.Append(CXXFLAGS = '-Wno-write-strings')

initialEnvironment.Prepend(CPPPATH = ['#/.', '#/H'])
initialEnvironment.Prepend(CPPPATH = ['.', './H']) # The swig builder sucks

if initialEnvironment['useLrint'] != '0':
    initialEnvironment.Prepend(CCFLAGS = ['-DUSE_LRINT'])
if initialEnvironment['useGettext'] != '0':
    print "Using GNU gettext scheme"
    initialEnvironment.Prepend(CCFLAGS = ['-DGNU_GETTEXT'])
    if util.platform == "win32":
        initialEnvironment.Append(LIBS=['intl'])
else:
    print "Using Istvan localisation"
    initialEnvironment.Prepend(CCFLAGS = ['-DNOGETTEXT'])

if initialEnvironment['gcc3opt'] != '0' or initialEnvironment['gcc4opt'] != '0':
    initialEnvironment.Prepend(CCFLAGS = Split(
        '-fomit-frame-pointer -ffast-math'))
    if initialEnvironment['gcc4opt'] != '0':
        initialEnvironment.Prepend(CCFLAGS = ['-ftree-vectorize'])
        cpuType = initialEnvironment['gcc4opt']
    else:
        cpuType = initialEnvironment['gcc3opt']
    if util.platform == 'darwin':
        initialEnvironment.Prepend(CCFLAGS = Split(
            '-O3 -mcpu=%s -mtune=%s' % (cpuType, cpuType)))
    else:
        initialEnvironment.Prepend(CCFLAGS = Split('-O3 -mtune=%s' % (cpuType)))

if initialEnvironment['buildRelease'] != '0':
    if util.compilerMicrosoft():
        initialEnvironment.Append(CCFLAGS = Split('/O2'))
    elif util.compilerIntel():
        initialEnvironment.Append(CCFLAGS = Split('/O3'))

if initialEnvironment['noDebug'] == '0':
    if util.compilerGNU()           : initialEnvironment.Append(CCFLAGS = ['-g'])

if initialEnvironment['useGprof'] == '1':
    initialEnvironment.Append(CCFLAGS = ['-pg'])
    initialEnvironment.Append(LINKFLAGS = ['-pg'])

if util.compilerGNU():
    initialEnvironment.Prepend(CXXFLAGS = ['-fexceptions'])

initialEnvironment.Prepend(LIBPATH = ['.', '#.'])

if initialEnvironment['buildRelease'] == '0':
    initialEnvironment.Prepend(CPPFLAGS = ['-DBETA'])

if initialEnvironment['Lib64'] == '1':
    initialEnvironment.Prepend(LIBPATH = ['.', '#.', '/usr/local/lib64'])
else:
    initialEnvironment.Prepend(LIBPATH = ['.', '#.', '/usr/local/lib'])

if initialEnvironment['Word64'] == '1':
    initialEnvironment.Append(CCFLAGS = ['-fPIC'])

if initialEnvironment['useDouble'] == '0':
    print 'CONFIGURATION DECISION: Using single-precision floating point for audio samples.'
else:
    print 'CONFIGURATION DECISION: Using double-precision floating point for audio samples.'
    initialEnvironment.Append(CPPFLAGS = ['-DUSE_DOUBLE'])

if initialEnvironment['buildSDFT'] == '1':
    initialEnvironment.Prepend(CPPFLAGS = ['-DSDFT'])

# Define different build environments for different types of targets.

if util.platform == 'linux':
    initialEnvironment.Append(CCFLAGS   = "-DLINUX")
    initialEnvironment.Append(CPPFLAGS  = '-DHAVE_SOCKETS')
    initialEnvironment.Append(CPPPATH   = '/usr/local/include')
    initialEnvironment.Append(CPPPATH   = '/usr/include')
    initialEnvironment.Append(CPPPATH   = '/usr/include')
    initialEnvironment.Append(CPPPATH   = '/usr/X11R6/include')
    initialEnvironment.Append(CCFLAGS   = "-DPIPES")
    initialEnvironment.Append(LINKFLAGS = ['-Wl,-Bdynamic'])
elif util.platform == 'darwin':
    initialEnvironment.Append(CCFLAGS   = "-DMACOSX")
    initialEnvironment.Append(CPPPATH   = '/usr/local/include')
    initialEnvironment.Append(CCFLAGS   = "-DPIPES")
    if initialEnvironment['useAltivec'] == '1':
        print 'CONFIGURATION DECISION using Altivec optmisation'
        initialEnvironment.Append(CCFLAGS = "-faltivec")
elif util.platform == 'win32':
    initialEnvironment.Append(CCFLAGS   =  '-D_WIN32')
    initialEnvironment.Append(CCFLAGS   =  '-DWIN32')
    initialEnvironment.Append(CCFLAGS   =  '-DPIPES')
    initialEnvironment.Append(CCFLAGS   =  '-DOS_IS_WIN32')
    initialEnvironment.Append(CXXFLAGS  = '-D_WIN32')
    initialEnvironment.Append(CXXFLAGS  = '-DWIN32')
    initialEnvironment.Append(CXXFLAGS  = '-DPIPES')
    initialEnvironment.Append(CXXFLAGS  = '-DOS_IS_WIN32')
    if util.compilerGNU():
        initialEnvironment.Prepend(CCFLAGS  = "-Wall")
        initialEnvironment.Append(CPPPATH   = '/usr/local/include')
        initialEnvironment.Append(CPPPATH   = '/usr/include')
        initialEnvironment.Append(CCFLAGS   = '-mthreads')
	initialEnvironment.Append(SHLINKFLAGS = 
            Split('''-mwindows -mno-cygwin -Wl,--enable-auto-import
                  -Wl,--enable-runtime-pseudo-reloc'''))
    else:
        initialEnvironment.Append(CCFLAGS   =  '/DMSVC')
        initialEnvironment.Append(CXXFLAGS  = '/EHsc')
        initialEnvironment.Append(CCFLAGS   =  '/D_CRT_SECURE_NO_DEPRECATE')
        initialEnvironment.Append(CCFLAGS   =  '/MD')
        initialEnvironment.Append(CCFLAGS   =  '/W2')
        initialEnvironment.Append(CCFLAGS   =  '/wd4251')
        initialEnvironment.Append(CCFLAGS   =  '/wd4996')
        initialEnvironment.Append(CCFLAGS   =  '/MP')
        initialEnvironment.Append(CCFLAGS   =  '/GR')
        initialEnvironment.Append(CCFLAGS   =  '/G7')
        initialEnvironment.Prepend(CCFLAGS  = Split('/Zi /D_NDEBUG /DNDEBUG'))
        initialEnvironment.Prepend(LINKFLAGS = Split('''/INCREMENTAL:NO /OPT:REF /OPT:ICF /DEBUG'''))
        initialEnvironment.Prepend(SHLINKFLAGS = Split(
            '/INCREMENTAL:NO /OPT:REF /OPT:ICF /DEBUG'))
        # With Visual C++ it is now necessary to embed the manifest into the target.
        initialEnvironment['LINKCOM'] = [initialEnvironment['LINKCOM'],
        'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;1']
        initialEnvironment['SHLINKCOM'] = [initialEnvironment['SHLINKCOM'],
        'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;2']
    if util.compilerMicrosoft():
        initialEnvironment.Append(CCFLAGS =  '/arch:sse')
    if util.compilerIntel():
        print 'Generating code optimized for Intel Core 2 Duo and Pentium 4'
        print 'that will run on other processors also.'
        initialEnvironment.Append(CCFLAGS = Split('/O3 /QaxTP'))

if util.platform == 'linux':
    path1 = '/usr/include/python%s' % initialEnvironment['pythonVersion']
    path2 = '/usr/local/include/python%s' % initialEnvironment['pythonVersion']
    pythonIncludePath   = [path1, path2]
    path1               = '/usr/include/tcl8.4'
    path2               = '/usr/include/tk8.4'
    tclIncludePath      = [path1, path2]
    pythonLinkFlags     = []
    if initialEnvironment['Lib64'] == '1':
        tmp = '/usr/lib64/python%s/config' % initialEnvironment['pythonVersion']
        pythonLibraryPath   = ['/usr/local/lib64', '/usr/lib64', tmp]
    else:
        tmp = '/usr/lib/python%s/config' % initialEnvironment['pythonVersion']
        pythonLibraryPath   = ['/usr/local/lib', '/usr/lib', tmp]
    pythonLibs              = ['python%s' % initialEnvironment['pythonVersion']]
elif util.platform == 'darwin':
    vers = (int(sys.hexversion) >> 24, (int(sys.hexversion) >> 16) & 255)
    if vers[1] == 3:
        print "Python version is 2.%s, using Apple Python Framework" % vers[1]
        pyBasePath = '/System/Library/Frameworks/Python.framework'
    else:
        print "Python version is 2.%s, using MacPython Framework"    % vers[1]
        pyBasePath = '/Library/Frameworks/Python.Framework'
    pvers = "2.%s" % vers[1]
    if initialEnvironment['pythonVersion'] != pvers:
        initialEnvironment['pythonVersion'] = pvers
        print "WARNING python version used is " + pvers
    pythonIncludePath   = ['%s/Headers' % pyBasePath]
    pythonLinkFlags     = [ '-F' + pyBasePath, '-framework', 'python']
    path1               = '%s/Versions/Current/lib' % pyBasePath
    path2 = '%s/python%s/config' % (path1, initialEnvironment['pythonVersion'])
    pythonLibraryPath   = [path1, path2]
    pythonLibs          = []
    tclIncludePath      = []
elif util.platform == 'win32':
    pythonIncludePath   = []
    pythonLinkFlags     = []
    pythonLibraryPath   = []
    tclIncludePath      = []
    pythonLibs          = ['python%s' %
        initialEnvironment['pythonVersion'].replace('.', '')]

# Check for prerequisites.
# We check only for headers; checking for libs may fail
# even if they are present, due to secondary dependencies.

libsndfileTests = [
    'int foobar(void)\n{\nreturn (int) SF_FORMAT_SD2;\n}',
    'int foobar(SF_INSTRUMENT *p)\n{\nreturn (int) p->loop_count;\n}',
    'int foobar(void)\n{\nreturn (int) SFC_GET_SIGNAL_MAX;\n}'
]

def CheckSndFile1011(context):
    context.Message('Checking for libsndfile version 1.0.11 or later... ')
    testProgram = '\n#include <sndfile.h>\n\n' + libsndfileTests[0] + '\n\n'
    result      = context.TryCompile(testProgram, '.c')
    context.Result(result)
    return result

def CheckSndFile1013(context):
    context.Message('Checking for libsndfile version 1.0.13 or later... ')
    testProgram = '\n#include <sndfile.h>\n\n' + libsndfileTests[1] + '\n\n'
    result      = context.TryCompile(testProgram, '.c')
    context.Result(result)
    return result

def CheckSndFile1016(context):
    context.Message('Checking for libsndfile version 1.0.16 or later... ')
    testProgram = '\n#include <sndfile.h>\n\n' + libsndfileTests[2] + '\n\n'
    result      = context.TryCompile(testProgram, '.c')
    context.Result(result)
    return result

def CheckGcc4(context):
    # We need gcc4 if we want -fvisibility=hidden
    context.Message('Checking for gcc version 4 or later... ')
    testProgram = '''int main() {
        #if __GNUC__ >= 4
        /* OK */
           return 0;
        #else /* GCC < 4.0 */
        #error __GNUC__ < 4
        #endif
        }
    '''
    result = context.TryCompile(testProgram, '.c' )
    context.Result(result)
    return result

configure = initialEnvironment.Configure(custom_tests = {
    'CheckSndFile1011' : CheckSndFile1011,
    'CheckSndFile1013' : CheckSndFile1013,
    'CheckSndFile1016' : CheckSndFile1016,
    'CheckGcc4'        : CheckGcc4
})

if not configure.CheckHeader("stdio.h", language = "C"):
    print " *** Failed to compile a simple test program. The compiler is"
    print " *** possibly not set up correctly, or is used with invalid flags."
    print " *** Check config.log to find out more about the error."
    Exit(-1)
if not configure.CheckLibWithHeader("sndfile", "sndfile.h", language = "C"):
    print "The sndfile library is required to build Csound 5."
    Exit(-1)
vstHeader   = "frontends/CsoundVST/vstsdk2.4/public.sdk/source/vst2.x/audioeffectx.h"
vstSdkFound = configure.CheckHeader(vstHeader, language = "C++")
if not buildOLPC:
    portaudioFound = configure.CheckLibWithHeader(
        "portaudio","portaudio.h", language = "C")
    portmidiFound = configure.CheckLibWithHeader(
        "portmidi", "portmidi.h", language = "C")
    fltkFound = configure.CheckLibWithHeader(
        "fltk", "FL/Fl.H", language = "C++")
boostFound = configure.CheckHeader("boost/any.hpp", language = "C++")
alsaFound  = configure.CheckLibWithHeader(
    "asound", "alsa/asoundlib.h", language = "C")
oscFound   = configure.CheckLibWithHeader("lo", "lo/lo.h", language = "C")
if not buildOLPC:
    jackFound   = configure.CheckLibWithHeader(
        "jack", "jack/jack.h", language = "C")
stkFound        = configure.CheckHeader(
    "Opcodes/stk/include/Stk.h", language = "C++")
tclhfound       = configure.CheckHeader(
    "tcl.h", language = "C")
if not tclhfound:
    for i in tclIncludePath:
        tclhfound = tclhfound or configure.CheckHeader(
        '%s/tcl.h' % i, language = "C")
midiPluginSdkFound  = configure.CheckHeader("funknown.h", language = "C++")
luaFound            = configure.CheckHeader("lua5.1/lua.h", language = "C")

if not buildOLPC    : luaFound = False

swigFound = 'swig' in initialEnvironment['TOOLS']
print 'Checking for SWIG... %s' % (['no', 'yes'][int(swigFound)])

pythonFound = configure.CheckHeader("Python.h", language = "C")
if not pythonFound:
    for i in pythonIncludePath:
        pythonFound = pythonFound or configure.CheckHeader(
            '%s/Python.h' % i, language = "C")

if util.platform == 'darwin':
    javaFound   = configure.CheckHeader(
        "/System/Library/Frameworks/JavaVM.Framework/Headers/jni.h",
        language = "C++")
else:
    javaFound   = configure.CheckHeader("jni.h", language = "C++")
if util.platform == 'linux' and not javaFound:
    if initialEnvironment['buildInterfaces'] != '0':
        if initialEnvironment['buildJavaWrapper'] != '0':
            baseDir = '/usr/lib'
            if initialEnvironment['Lib64'] == '1':
                baseDir += '64'
            for i in ['java', 'jvm/java', 'jvm/java-1.5.0']:
                javaIncludePath = '%s/%s/include' % (baseDir, i)
                tmp = '%s/linux/jni_md.h' % javaIncludePath
                if configure.CheckHeader(tmp, language = "C++"):
                    javaFound = 1
                    break
    if javaFound:
        initialEnvironment.Append(CPPPATH = [javaIncludePath])
        initialEnvironment.Append(CPPPATH = [javaIncludePath + '/linux'])

if util.platform == 'win32':
    initialEnvironment['ENV']['PATH']   = os.environ['PATH']
    initialEnvironment['SYSTEMROOT']    = os.environ['SYSTEMROOT']

if vstSdkFound:
    initialEnvironment.Prepend(CPPFLAGS = ['-DHAVE_VST_SDK'])


# Define macros that configure and config.h used to define.
headerMacroCheck = [
    ['io.h',        '-DHAVE_IO_H'       ],
    ['fcntl.h',     '-DHAVE_FCNTL_H'    ],
    ['unistd.h',    '-DHAVE_UNISTD_H'   ],
    ['stdint.h',    '-DHAVE_STDINT_H'   ],
    ['sys/time.h',  '-DHAVE_SYS_TIME_H' ],
    ['sys/types.h', '-DHAVE_SYS_TYPES_H'],
    ['termios.h',   '-DHAVE_TERMIOS_H'  ]]

for h in headerMacroCheck:
    if configure.CheckHeader(h[0], language = "C"):
        initialEnvironment.Append(CPPFLAGS = [h[1]])

if util.platform == 'win32':
    if configure.CheckHeader("winsock.h", language = "C"):
        initialEnvironment.Append(CPPFLAGS = '-DHAVE_SOCKETS')
elif configure.CheckHeader("sys/socket.h", language = "C"):
    initialEnvironment.Append(CPPFLAGS = '-DHAVE_SOCKETS')

if util.platform == 'darwin':
    initialEnvironment.Append(CPPFLAGS = '-DHAVE_DIRENT_H')
elif configure.CheckHeader("dirent.h", language = "C"):
    initialEnvironment.Append(CPPFLAGS = '-DHAVE_DIRENT_H')

if configure.CheckSndFile1016():
    initialEnvironment.Prepend(CPPFLAGS = ['-DHAVE_LIBSNDFILE=1016'])
elif configure.CheckSndFile1013():
    initialEnvironment.Prepend(CPPFLAGS = ['-DHAVE_LIBSNDFILE=1013'])
elif configure.CheckSndFile1011():
    initialEnvironment.Prepend(CPPFLAGS = ['-DHAVE_LIBSNDFILE=1011'])
else:
    initialEnvironment.Prepend(CPPFLAGS = ['-DHAVE_LIBSNDFILE=1000'])

# Package contents.

# library version is CS_VERSION.CS_APIVERSION
csoundLibraryVersion = '5.1'
csoundLibraryName = 'csound'
if initialEnvironment['useDouble'] != '0'   : csoundLibraryName += '64'
elif util.platform == 'win32'               : csoundLibraryName += '32'
# flags for linking with the Csound library
libCsoundLinkFlags = []
libCsoundLibs = ['sndfile']

buildOSXFramework = 0
if util.platform == 'darwin':
    if initialEnvironment['dynamicCsoundLibrary'] != '0':
        buildOSXFramework = 1
        CsoundLib_OSX = 'CsoundLib'
        # comment the next two lines out to disable building a separate
        # framework (CsoundLib64) for double precision
        if initialEnvironment['useDouble'] != '0':
            CsoundLib_OSX += '64'
        OSXFrameworkBaseDir = '%s.Framework' % CsoundLib_OSX
        tmp = OSXFrameworkBaseDir + '/Versions/%s'
        OSXFrameworkCurrentVersion = tmp % csoundLibraryVersion

csoundLibraryEnvironment = initialEnvironment.Clone()

if initialEnvironment['buildNewParser'] != '0':
    if util.platform == "win32":
        Tool('lex')(csoundLibraryEnvironment)
        Tool('yacc')(csoundLibraryEnvironment)
    print 'CONFIGURATION DECISION: Building with new parser enabled'
    csoundLibraryEnvironment.Append(
        YACCFLAGS = ['-d', '--report=itemset', '-p','csound_orc'])
    csoundLibraryEnvironment.Append(LEXFLAGS = ['-d', '-Pcsound_orc'])
    csoundLibraryEnvironment.Append(CPPFLAGS = ['-DENABLE_NEW_PARSER'])
    yaccBuild = csoundLibraryEnvironment.CFile(
        target = 'Engine/csound_orcparse.c',
        source = 'Engine/csound_orc.y')
    lexBuild = csoundLibraryEnvironment.CFile(
        target = 'Engine/csound_orclex.c',
        source = 'Engine/csound_orc.l')
else:
    print 'CONFIGURATION DECISION: Not building with new parser.'

csoundLibraryEnvironment.Append(CPPFLAGS = ['-D__BUILDING_LIBCSOUND'])
if initialEnvironment['buildRelease'] != '0':
    csoundLibraryEnvironment.Append(CPPFLAGS = ['-D_CSOUND_RELEASE_'])
    if util.platform == 'linux':
        if initialEnvironment['Lib64'] == '0':
            tmp = '%s/lib/csound/plugins' % initialEnvironment['prefix']
        else:
            tmp = '%s/lib64/csound/plugins' % initialEnvironment['prefix']
        if initialEnvironment['useDouble'] != '0':
            tmp += '64'
        s = '-DCS_DEFAULT_PLUGINDIR=\\"%s\\"' % tmp
        csoundLibraryEnvironment.Append(CPPFLAGS = [s])
    elif buildOSXFramework != 0:
        tmp = '/Library/Frameworks/%s' % OSXFrameworkCurrentVersion
        tmp += '/Resources/Opcodes'
        if initialEnvironment['useDouble'] != '0':
            tmp += '64'
        s = '-DCS_DEFAULT_PLUGINDIR=\\"%s\\"' % tmp
        csoundLibraryEnvironment.Append(CPPFLAGS = [s])
csoundDynamicLibraryEnvironment = csoundLibraryEnvironment.Clone()
csoundDynamicLibraryEnvironment.Append(LIBS = ['sndfile'])
if util.platform == 'win32':
    # These are the Windows system call libraries.
    if util.compilerGNU():
        csoundWindowsLibraries = Split('''
            advapi32    comctl32    comdlg32    glu32       kernel32
            msvcrt      odbc32      odbccp32    ole32       oleaut32
            shell32     user32      uuid        winmm       winspool
            ws2_32      wsock32     advapi32    comctl32    comdlg32
            glu32       kernel32    odbc32      odbccp32    ole32
            oleaut32    shell32     user32      uuid        winmm
            winspool    ws2_32      wsock32
        ''')
    else:
        csoundWindowsLibraries = Split('''
            kernel32        gdi32           wsock32         ole32
            uuid            winmm           user32.lib      ws2_32.lib
            comctl32.lib    gdi32.lib       comdlg32.lib    advapi32.lib
            shell32.lib     ole32.lib       oleaut32.lib    uuid.lib
            odbc32.lib      odbccp32.lib    bufferoverflowu kernel32.lib
            user32.lib      gdi32.lib       winspool.lib    comdlg32.lib
            advapi32.lib    shell32.lib     ole32.lib       oleaut32.lib
            uuid.lib        odbc32.lib      odbccp32.lib    bufferoverflowu
        ''')
    csoundDynamicLibraryEnvironment.Append(LIBS = csoundWindowsLibraries)
    if util.compilerGNU():
        csoundDynamicLibraryEnvironment.Append(SHLINKFLAGS = ['-module'])
elif util.platform == 'linux':
    csoundDynamicLibraryEnvironment.Append(LIBS = ['dl', 'm', 'pthread'])
csoundInterfacesEnvironment = csoundDynamicLibraryEnvironment.Clone()

if buildOSXFramework:
    csoundFrameworkEnvironment = csoundDynamicLibraryEnvironment.Clone()
    # create directory structure for the framework
    tmp = [OSXFrameworkBaseDir]
    tmp += ['%s/Versions' % OSXFrameworkBaseDir]
    tmp += [OSXFrameworkCurrentVersion]
    tmp += ['%s/Headers' % OSXFrameworkCurrentVersion]
    tmp += ['%s/Resources' % OSXFrameworkCurrentVersion]
    if initialEnvironment['useDouble'] == '0':
        tmp += ['%s/Resources/Opcodes' % OSXFrameworkCurrentVersion]
    else:
        tmp += ['%s/Resources/Opcodes64' % OSXFrameworkCurrentVersion]
    for i in tmp:
        try:
            os.mkdir(i, 0755)
        except:
            pass
    # set up symbolic links
    tmp = [['/Versions/Current', csoundLibraryVersion]]
    tmp += [['/' + CsoundLib_OSX, 'Versions/Current/' + CsoundLib_OSX]]
    tmp += [['/Headers', 'Versions/Current/Headers']]
    tmp += [['/Resources', 'Versions/Current/Resources']]
    for i in tmp:
        try:
            os.remove('%s/%s' % (OSXFrameworkBaseDir, i[0]))
        except:
            pass
        os.symlink(i[1], '%s/%s' % (OSXFrameworkBaseDir, i[0]))

libEngine = '''
Engine/auxfd.c      Engine/cfgvar.c     Engine/entry1.c     Engine/envvar.c
Engine/express.c    Engine/extract.c    Engine/fgens.c      Engine/insert.c
Engine/linevent.c   Engine/memalloc.c   Engine/memfiles.c   Engine/musmon.c
Engine/namedins.c   Engine/otran.c      Engine/rdorch.c     Engine/rdscor.c
Engine/scsort.c     Engine/scxtract.c   Engine/sort.c       Engine/sread.c
Engine/swrite.c     Engine/twarp.c
'''
libSndMid = '''
InOut/libsnd.c      InOut/libsnd_u.c    InOut/midifile.c    InOut/midirecv.c
InOut/midisend.c    InOut/winascii.c    InOut/windin.c      InOut/window.c
'''
libOO = '''
OOps/aops.c         OOps/bus.c          OOps/cmath.c        OOps/diskin.c
OOps/diskin2.c      OOps/disprep.c      OOps/dumpf.c        OOps/fftlib.c
OOps/goto_ops.c     OOps/midiinterop.c  OOps/midiops.c      OOps/midiout.c
OOps/mxfft.c        OOps/oscils.c       OOps/pstream.c      OOps/pvfileio.c
OOps/pvsanal.c      OOps/random.c       OOps/remote.c       OOps/schedule.c
OOps/sndinfUG.c     OOps/str_ops.c      OOps/ugens1.c       OOps/ugens2.c
OOps/ugens3.c       OOps/ugens4.c       OOps/ugens5.c       OOps/ugens6.c
OOps/ugrw1.c        OOps/ugrw2.c        OOps/vdelay.c
'''

if buildOLPC:
    libCsoundSources = Split( libEngine + libSndMid + libOO + '''
Top/argdecode.c     Top/csmodule.c      Top/csound.c        Top/getstring.c
Top/main.c          Top/new_opts.c      Top/one_file.c      Top/opcode.c
Top/threads.c       Top/utility.c
''')
else:
    libCsoundSources = Split(libEngine + libSndMid + libOO + '''
Top/argdecode.c Top/cscore_internal.c   Top/cscorfns.c  Top/csmodule.c
Top/csound.c    Top/getstring.c         Top/main.c      Top/new_opts.c
Top/one_file.c  Top/opcode.c            Top/threads.c   Top/utility.c
InOut/winEPS.c
''')

newParserSources = Split('''
Engine/csound_orclex.c          Engine/csound_orcparse.c
Engine/csound_orc_semantics.c   Engine/csound_orc_expressions.c
Engine/csound_orc_optimize.c    Engine/csound_orc_compile.c
Engine/new_orc_parser.c         Engine/symbtab.c
''')

if initialEnvironment['buildNewParser'] != '0':
    libCsoundSources += newParserSources

csoundLibraryEnvironment.Append(CCFLAGS='-fPIC')
if initialEnvironment['dynamicCsoundLibrary'] == '1':
    print 'CONFIGURATION DECISION: Building dynamic Csound library'
    if util.platform == 'linux':
        # The linker will pull in dependencies
        libCsoundLibs   = []
        libName         = 'lib' + csoundLibraryName + '.so'
        libName2        = libName + '.' + csoundLibraryVersion
        try     : os.symlink(libName2, libName)
        except  : pass
        Clean(libName2, libName) # Delete the symlink on clean
        tmp = csoundDynamicLibraryEnvironment['SHLINKFLAGS']
        tmp += ['-Wl,-soname=%s' % libName2]
        cflags = csoundDynamicLibraryEnvironment['CCFLAGS']
        if configure.CheckGcc4():
            cflags   += ['-fvisibility=hidden']
        csoundLibrary = csoundDynamicLibraryEnvironment.SharedLibrary(
            libName2, libCsoundSources,
            SHLINKFLAGS = tmp, SHLIBPREFIX = '', SHLIBSUFFIX = '',
            CCFLAGS = cflags)
    elif util.platform == 'darwin':
        libName = CsoundLib_OSX
        libVersion = csoundLibraryVersion
        csoundFrameworkEnvironment.Append(SHLINKFLAGS = Split('''
            -Xlinker -compatibility_version -Xlinker %s
        ''' % libVersion))
        csoundFrameworkEnvironment.Append(SHLINKFLAGS = Split('''
            -Xlinker -current_version -Xlinker %s
        ''' % libVersion))
        csoundFrameworkEnvironment.Append(SHLINKFLAGS = Split('''
            -install_name /Library/Frameworks/%s/%s
        ''' % (OSXFrameworkCurrentVersion, libName)))
        csoundLibraryFile = csoundFrameworkEnvironment.SharedLibrary(
            libName, libCsoundSources, SHLIBPREFIX = '', SHLIBSUFFIX = '')
        csoundFrameworkEnvironment.Command(
            '%s/%s' % (OSXFrameworkCurrentVersion, libName), libName,
            'cp -f %s %s/' % (libName, OSXFrameworkCurrentVersion))
        for i in headers:
            util.MacOSX_InstallHeader(i)
        tmp = (OSXFrameworkBaseDir, OSXFrameworkBaseDir)
        csoundLibrary = csoundFrameworkEnvironment.Command(
            'CsoundLib_install', libName,
            'rm -r /Library/Frameworks/%s; cp -R %s /Library/Frameworks/' % tmp)
        libCsoundLinkFlags = ['-F.', '-framework', libName, '-lsndfile']
        libCsoundLibs = []
    elif util.platform == 'win32':
        csoundLibrary = csoundDynamicLibraryEnvironment.SharedLibrary(
            csoundLibraryName, libCsoundSources,
            SHLIBSUFFIX = '.dll.%s' % csoundLibraryVersion)
        if util.compilerGNU():
            libCsoundLinkFlags.append('--subsystem:windows')
            libCsoundLibs += [ 'stdc++', 'supc++']
        else:
            libCsoundLinkFlags.append('/IMPLIB:dummy.lib')
        libCsoundLibs += csoundWindowsLibraries
    else: # Is this useful?
        csoundLibrary = csoundDynamicLibraryEnvironment.SharedLibrary(
            csoundLibraryName, libCsoundSources)
else:
    print 'CONFIGURATION DECISION: Building static Csound library'
    csoundLibraryEnvironment.Append(CCFLAGS='-fPIC')
    if util.platform == 'linux':
        libCsoundLibs.append('dl')
    if util.platform != 'win32':
        libCsoundLibs += ['pthread', 'm']
    if util.platform == 'win32':
        libCsoundLibs += csoundWindowsLibraries
    if util.platform == 'darwin':
        libCsoundLinkFlags += Split(
            '-framework Carbon -framework CoreAudio -framework CoreMidi')
    csoundLibrary = csoundLibraryEnvironment.Library(
        csoundLibraryName, libCsoundSources)

if not util.platform == 'win32' : libCsoundLibs.append(csoundLibrary)
else                            : libCsoundLibs.append(csoundLibraryName)
libs.append(csoundLibrary)
# Make everything link (correctly) against libcsound, even if not needed.
# FIXME: when linking statically this may lead to larger than normal binaries.
# Stripping should help (?). It appears that at least gcc doesn't link
# statically if no symbols are referenced.
commonEnvironment = initialEnvironment.Clone()
commonEnvironment.Append( LIBS      = libCsoundLibs )
commonEnvironment.Append( LINKFLAGS = libCsoundLinkFlags )

#############################################################################
#
#   DEFINE TARGETS AND SOURCES
#
#############################################################################

if util.platform == 'win32':
    PYDLL = r'%s\%s' % (os.environ['SystemRoot'], pythonLibs[0])
if util.platform == 'win32' and pythonLibs[0] < 'python24' and util.compilerGNU():
    tmp = 'dlltool --input-def %s.def --dllname %s.dll --output-lib /usr/local/lib/lib%s.a'
    pythonImportLibrary = csoundInterfacesEnvironment.Command(
        '/usr/local/lib/lib%s.a' % (pythonLibs[0]), PYDLL,
        ['pexports %s > %s.def' % (PYDLL, pythonLibs[0]),
         tmp % (pythonLibs[0], PYDLL, pythonLibs[0])])

if not ((pythonFound or luaFound or javaFound) and swigFound and commonEnvironment['buildInterfaces'] == '1'):
    print 'CONFIGURATION DECISION: Not building Csound interfaces library.'
else:
    print 'CONFIGURATION DECISION: Building Csound interfaces library.'
    print "Python Version: " + commonEnvironment['pythonVersion']
    csoundInterfacesEnvironment.Append(CPPPATH = ['interfaces'])
    csoundInterfacesSources = []
    for i in Split('CppSound CsoundFile Soundfile csPerfThread cs_glue filebuilding'):
        csoundInterfacesSources.append(csoundInterfacesEnvironment.SharedObject(
            'interfaces/%s.cpp' % i))
    if util.platform == 'win32' and util.compilerGNU():
        csoundInterfacesEnvironment.Append(
            SHLINKFLAGS = '-Wl,--add-stdcall-alias')
    elif util.platform == 'linux':
        csoundInterfacesEnvironment.Prepend(LIBS = ['util'])
    if util.compilerGNU():
        csoundInterfacesEnvironment.Prepend(LIBS = ['stdc++'])
    csoundInterfacesEnvironment.Append(SWIGFLAGS = Split('''-c++ -includeall -verbose'''))
    csoundWrapperEnvironment = csoundInterfacesEnvironment.Clone()
    util.fixCFlagsForSwig(csoundWrapperEnvironment)
    csoundWrapperEnvironment.Append(CPPFLAGS = '-D__BUILDING_CSOUND_INTERFACES')
    for option in csoundWrapperEnvironment['CCFLAGS']:
        if string.find(option, '-D') == 0:
            csoundWrapperEnvironment.Append(SWIGFLAGS = [option])
    for option in csoundWrapperEnvironment['CPPFLAGS']:
        if string.find(option, '-D') == 0:
            csoundWrapperEnvironment.Append(SWIGFLAGS = [option])
    for option in csoundWrapperEnvironment['CPPPATH']:
        csoundWrapperEnvironment.Append(SWIGFLAGS = ['-I' + option])
    swigflags = csoundWrapperEnvironment['SWIGFLAGS']
    if not (javaFound and commonEnvironment['buildJavaWrapper'] != '0'):
        print 'CONFIGURATION DECISION: Not building Java wrappers for Csound interfaces library.'
    else:
        print 'CONFIGURATION DECISION: Building Java wrappers for Csound interfaces library.'
        csoundJavaWrapperEnvironment = csoundInterfacesEnvironment.Clone()
        if util.platform == 'darwin':
            csoundWrapperEnvironment.Append(CPPPATH =
                ['/System/Library/Frameworks/JavaVM.Framework/Headers'])
        if util.platform == 'linux':
            # ugly hack to work around bug that requires running scons twice
            tmp = [csoundWrapperEnvironment['SWIG']]
            for i in swigflags:
                tmp += [i]
            tmp += ['-java', '-package', 'csnd']
            tmp += ['-o', 'interfaces/java_interface_wrap.cc']
            tmp += ['interfaces/java_interface.i']
            if os.spawnvp(os.P_WAIT, tmp[0], tmp) != 0:
                Exit(-1)
            csoundJavaWrapperSources = [csoundWrapperEnvironment.SharedObject(
                'interfaces/java_interface_wrap.cc')]
        else:
            csoundJavaWrapperSources = [csoundWrapperEnvironment.SharedObject(
                'interfaces/java_interface.i',
                SWIGFLAGS = [swigflags, '-java', '-package', 'csnd'])]
        csoundJavaWrapperSources += ['interfaces/pyMsgCb_stub.cpp']
        csoundJavaWrapperSources += csoundInterfacesSources

        if util.platform == 'darwin':
            csoundJavaWrapperEnvironment.Prepend(LINKFLAGS  = ['-bundle'])
            csoundJavaWrapperEnvironment.Append(
                LINKFLAGS   = ['-framework', 'JavaVM', '-Wl'])
            csoundJavaWrapper = csoundJavaWrapperEnvironment.Program(
                'lib_jcsound.jnilib', csoundJavaWrapperSources)
        else:
            csoundJavaWrapper = csoundJavaWrapperEnvironment.SharedLibrary(
                '_jcsound', csoundJavaWrapperSources)
        Depends(csoundJavaWrapper, csoundLibrary)
        libs.append(csoundJavaWrapper)
        jcsnd = csoundJavaWrapperEnvironment.Java(
            target      = './interfaces', source = './interfaces',
            JAVACFLAGS  = ['-source', '1.4', '-target', '1.4'])
        try     : os.mkdir('interfaces/csnd', 0755)
        except  : pass
        jcsndJar = csoundJavaWrapperEnvironment.Jar(
            'csnd.jar', ['interfaces/csnd'], JARCHDIR = 'interfaces')
        Depends(jcsndJar, jcsnd)
        libs.append(jcsndJar)
    csoundInterfacesSources.insert(0,
        csoundInterfacesEnvironment.SharedObject('interfaces/pyMsgCb.cpp'))
    if not luaFound:
        print 'CONFIGURATION DECISION: Not building Csound Lua interface library.'
    else:
        print 'CONFIGURATION DECISION: Building Csound Lua interface library.'
        csoundWrapperEnvironment.Append(CPPPATH=['/usr/include/lua5.1'])
        csoundLuaInterface = csoundWrapperEnvironment.SharedObject(
            'interfaces/lua_interface.i',
            SWIGFLAGS = [swigflags, '-lua', '-outdir', '.'])
        if util.platform != 'darwin':
            csoundInterfacesSources.insert(0, csoundLuaInterface)
            if util.platform == 'win32':
                csoundInterfacesEnvironment.Prepend(LIBS = ['lua51'])
            else:
                csoundInterfacesEnvironment.Prepend(LIBS = ['lua'])
    if util.platform == 'linux':
        os.spawnvp(os.P_WAIT, 'rm', ['rm', '-f', '_csnd.so'])
        # os.symlink('lib_csnd.so', '_csnd.so')
        csoundInterfacesEnvironment.Append(LINKFLAGS = ['-Wl,-rpath-link,.'])
    if util.platform == 'darwin':
        if commonEnvironment['dynamicCsoundLibrary'] == '1':
            ilibName = "lib_csnd.dylib"
            ilibVersion = csoundLibraryVersion
            csoundInterfacesEnvironment.Append(SHLINKFLAGS = Split(
                '''-Xlinker -compatibility_version
                -Xlinker %s''' % ilibVersion))
            csoundInterfacesEnvironment.Append(SHLINKFLAGS = Split(
                '''-Xlinker -current_version -Xlinker %s''' % ilibVersion))
            tmp = '''-install_name
                /Library/Frameworks/CsoundLib.framework/Versions/%s/%s'''
            csoundInterfacesEnvironment.Append(SHLINKFLAGS = Split(
                 tmp % ('5.1', ilibName)))
            csoundInterfaces = csoundInterfacesEnvironment.SharedLibrary(
                '_csnd', csoundInterfacesSources)
        else:
            csoundInterfaces = csoundInterfacesEnvironment.Library(
                '_csnd', csoundInterfacesSources)
    elif util.platform == 'linux':
        name    = 'libcsnd.so'
        soname  = name + '.' + csoundLibraryVersion
        try     : os.symlink(soname, name)
        except  : pass
        Clean(soname, name) #Delete symlink on clean
        linkflags = csoundInterfacesEnvironment['SHLINKFLAGS']
        soflag = [ '-Wl,-soname=%s' % soname ]
        extraflag = ['-L.']
        csoundInterfaces = csoundInterfacesEnvironment.SharedLibrary(
            soname, csoundInterfacesSources, 
            SHLINKFLAGS = linkflags+soflag+extraflag,
            SHLIBPREFIX = '', SHLIBSUFFIX = '')
    else:
        csoundInterfaces = csoundInterfacesEnvironment.SharedLibrary(
            'csnd', csoundInterfacesSources)
    Depends(csoundInterfaces, csoundLibrary)
    libs.append(csoundInterfaces)
    if pythonFound:
        csoundInterfacesEnvironment.Append(LINKFLAGS = pythonLinkFlags)
        if util.platform != 'darwin':
            csoundInterfacesEnvironment.Prepend(LIBPATH = pythonLibraryPath)
            csoundInterfacesEnvironment.Prepend(LIBS = pythonLibs)
        csoundInterfacesEnvironment.Append(CPPPATH = pythonIncludePath)
        csndPythonEnvironment = csoundInterfacesEnvironment.Clone()
        csndPythonEnvironment.Append(LIBS = csoundInterfaces)
        csoundPythonInterface = csndPythonEnvironment.SharedObject(
            'interfaces/python_interface.i',
            SWIGFLAGS = [swigflags, '-python', '-outdir', '.'])
        csndPythonEnvironment.Clean('.', 'interfaces/python_interface_wrap.h')
        if util.platform == 'win32' and pythonLibs[0] < 'python24' and util.compilerGNU():
            Depends(csoundPythonInterface, pythonImportLibrary)
        csndModule = util.makePythonModule(
            csndPythonEnvironment, 'csnd', [csoundPythonInterface])
        pythonModules.append('csnd.py')
        Depends(csoundPythonInterface, csoundInterfaces)

if commonEnvironment['generatePdf'] == '0':
    print 'CONFIGURATION DECISION: Not generating Csound API PDF documentation.'
else:
    print 'CONFIGURATION DECISION: Generating Csound API PDF documentation.'
    refmanTex = commonEnvironment.Command(
        'doc/latex/refman.tex', 'Doxyfile', ['doxygen $SOURCE'])
    Depends(refmanTex, csoundLibrary)
    csoundPdf = commonEnvironment.Command(
        'refman.pdf', 'doc/latex/refman.tex',
        ['pdflatex --include-directory=doc/latex --interaction=nonstopmode --job-name=CsoundAPI $SOURCE'])
    Depends(csoundPdf, refmanTex)

#############################################################################
#
# Plugins with External Dependencies
#############################################################################

# FLTK widgets

csoundProgramEnvironment    = commonEnvironment.Clone()
vstEnvironment              = commonEnvironment.Clone()
vstEnvironment.Append(CXXFLAGS = '-DVST_FORCE_DEPRECATED=0')
guiProgramEnvironment       = commonEnvironment.Clone()

fltkConfigFlags = 'fltk-config --use-images --cflags --cxxflags'
if util.platform != 'darwin':
    fltkConfigFlags += ' --ldflags'
try:
    if vstEnvironment.ParseConfig(fltkConfigFlags):
        print 'Parsed fltk-config.'
    else:
        print 'Could not parse fltk-config.'
except:
    print 'Exception when attempting to parse fltk-config.'
if util.platform == 'darwin':
    # fltk_png z fltk_jpeg are not on OSX at the mo
    vstEnvironment.Append(LIBS = Split('fltk fltk_images'))
if util.platform == 'win32':
    if util.compilerGNU():
        vstEnvironment.Append(          LINKFLAGS   = "--subsystem:windows")
        guiProgramEnvironment.Append(   LINKFLAGS   = "--subsystem:windows")
        vstEnvironment.Append(          LIBS        = ['stdc++', 'supc++'])
        guiProgramEnvironment.Append(   LIBS        = ['stdc++', 'supc++'])
    else:
        csoundProgramEnvironment.Append(LINKFLAGS = ["/IMPLIB:dummy.lib"])
else:
    if util.platform == 'linux':
        csoundProgramEnvironment.Append(LIBS = ['dl'])
        vstEnvironment.Append(          LIBS = ['dl'])
        guiProgramEnvironment.Append(   LIBS = ['dl'])
    csoundProgramEnvironment.Append(    LIBS = ['pthread', 'm'])
    vstEnvironment.Append(              LIBS = ['stdc++', 'pthread', 'm'])
    guiProgramEnvironment.Append(       LIBS = ['stdc++', 'pthread', 'm'])
    if util.platform == 'darwin':
        csoundProgramEnvironment.Append(LINKFLAGS = Split('''
            -framework Carbon -framework CoreAudio -framework CoreMidi
        '''))
pluginEnvironment = commonEnvironment.Clone()

# REAL TIME AUDIO AND MIDI

if commonEnvironment['useCoreAudio'] == '1' and util.platform == 'darwin':
    print "CONFIGURATION DECISION: Building CoreAudio plugin."
    coreaudioEnvironment = pluginEnvironment.Clone()
    coreaudioEnvironment.Append(
        CCFLAGS = '-I/system/library/Frameworks/CoreAudio.framework/Headers')
    util.makePlugin(coreaudioEnvironment, 'rtcoreaudio', ['InOut/rtcoreaudio.c'])
else:
    print "CONFIGURATION DECISION: Not building CoreAudio plugin."

if not (commonEnvironment['useALSA'] == '1' and alsaFound):
    print "CONFIGURATION DECISION: Not building ALSA plugin."
else:
    print "CONFIGURATION DECISION: Building ALSA plugin."
    alsaEnvironment = pluginEnvironment.Clone()
    alsaEnvironment.Append(LIBS = ['asound', 'pthread'])
    util.makePlugin(alsaEnvironment, 'rtalsa', ['InOut/rtalsa.c'])

if util.platform == 'win32':
    winmmEnvironment = pluginEnvironment.Clone()
    winmmEnvironment.Append(LIBS = ['winmm', 'gdi32', 'kernel32'])
    util.makePlugin(winmmEnvironment, 'rtwinmm', ['InOut/rtwinmm.c'])

if not (commonEnvironment['usePortAudio'] == '1' and portaudioFound):
    print "CONFIGURATION DECISION: Not building PortAudio module."
else:
    print "CONFIGURATION DECISION: Building PortAudio module."
    portaudioEnvironment = pluginEnvironment.Clone()
    if util.platform == 'win32':
       portaudioEnvironment.Append(LIBS = ['portaudio'])
    else:
       portaudioEnvironment.Append(LIBS = ['portaudio'])
    if (util.platform == 'linux'):
        if (commonEnvironment['useJack']=='1' and jackFound):
            print "Adding Jack library for PortAudio"
            portaudioEnvironment.Append(LIBS = ['jack'])
        portaudioEnvironment.Append(LIBS = ['pthread'])
        if alsaFound:
            portaudioEnvironment.Append(LIBS = ['asound'])
    elif util.platform == 'win32':
        portaudioEnvironment.Append(LIBS = ['winmm', 'dsound'])
    util.makePlugin(portaudioEnvironment, 'rtpa', ['InOut/rtpa.c'])

if not (commonEnvironment['useJack'] == '1' and jackFound):
    print "CONFIGURATION DECISION: Not building JACK plugin."
else:
    print "CONFIGURATION DECISION: Building JACK plugin."
    jackEnvironment = pluginEnvironment.Clone()
    if util.platform == 'linux':
        jackEnvironment.Append(LIBS = ['jack', 'pthread'])
        if alsaFound and portaudioFound:
            portaudioEnvironment.Append(LIBS = ['asound'])
    elif util.platform == 'win32':
        jackEnvironment.Append(LIBS = ['jackdmp', 'pthread'])
    else:
        jackEnvironment.Append(LIBS = ['jack', 'pthread'])
    util.makePlugin(jackEnvironment, 'rtjack', ['InOut/rtjack.c'])

if commonEnvironment['usePortMIDI'] == '1' and portmidiFound:
    print 'CONFIGURATION DECISION: Building with PortMIDI.'
    portMidiEnvironment = pluginEnvironment.Clone()
    portMidiEnvironment.Append(LIBS = ['portmidi'])
    if util.platform != 'darwin':
        portMidiEnvironment.Append(LIBS = ['porttime'])
    if util.platform == 'linux' and alsaFound:
        portMidiEnvironment.Append(LIBS = ['asound'])
    util.makePlugin(portMidiEnvironment, 'pmidi', ['InOut/pmidi.c'])
else:
    print 'CONFIGURATION DECISION: Not building with PortMIDI.'

#util.makePlugin(pluginEnvironment, 'asciimidi',
#                   ['InOut/ascii_midi_driver/ascii_midi_driver.cpp'])

# OGG opcodes
if buildOLPC:
    print "CONFIGURATION DECISION: Building OGG plugins."
    oggEnvironment = pluginEnvironment.Clone()
    oggEnvironment.Append(LINKFLAGS = ['-lvorbisfile', '-lvorbis', '-logg'])
    util.makePlugin(oggEnvironment, 'oggplay', ['Opcodes/oggplay.c'])
# end ogg opcodes

# VST HOST OPCODES
if (commonEnvironment['buildvst4cs'] != '1'):
    print "CONFIGURATION DECISION: Not building vst4cs opcodes."
else:
    print "CONFIGURATION DECISION: Building vst4cs opcodes."
    if (util.platform == 'win32'or util.platform == 'linux') and fltkFound:
        vst4Environment = vstEnvironment.Clone()
        vst4Environment.Append(CPPFLAGS = ['-DCS_VSTHOST'])
        vst4Environment.Append(CPPPATH  = ['frontends/CsoundVST'])
        if util.compilerGNU():
            vst4Environment.Append(LIBS = Split(
                'fltk_images fltk_png fltk_z fltk_jpeg fltk'))
            vst4Environment.Append(LIBS = ['stdc++'])
        else:
            vst4Environment.Append(LIBS = Split(
                'fltkimages fltkpng fltkz fltkjpeg fltk'))
        util.makePlugin(vst4Environment, 'vst4cs', Split('''
                        Opcodes/vst4cs/src/vst4cs.cpp
                        Opcodes/vst4cs/src/fxbank.cpp
                        Opcodes/vst4cs/src/vsthost.cpp
                        '''))
    elif util.platform == 'darwin' and fltkFound:
        vst4Environment = vstEnvironment.Clone()
        vst4Environment.Append(LIBS = ['fltk'])
        vst4Environment.Append(LIBS = ['stdc++'])
        vst4Environment.Append(LINKFLAGS =
            ['-framework', 'carbon', '-framework', 'ApplicationServices'])
        vst4Environment.Append(CPPPATH = ['frontends/CsoundVST'])
        vst4Environment.Append(CPPFLAGS = ['-DCS_VSTHOST'])
        util.makePlugin(vst4Environment, 'vst4cs', Split('''
            Opcodes/vst4cs/src/vst4cs.cpp Opcodes/vst4cs/src/fxbank.cpp
            Opcodes/vst4cs/src/vsthost.cpp
        '''))

# DSSI HOST OPCODES

if (commonEnvironment['buildDSSI'] == '1' and (util.platform == 'linux' or util.platform == 'darwin') and
configure.CheckHeader("ladspa.h", language = "C") and alsaFound):
    print "CONFIGURATION DECISION: Building DSSI plugin host opcodes."
    dssiEnvironment = pluginEnvironment.Clone()
    dssiEnvironment.Append(LIBS = ['dl'])
    dssiSrc = ['Opcodes/dssi4cs/src/load.c', 'Opcodes/dssi4cs/src/dssi4cs.c']
    util.makePlugin(dssiEnvironment, 'dssi4cs', dssiSrc)
else:
    print "CONFIGURATION DECISION: Not building DSSI plugin host opcodes."

# Loris opcodes

if not (commonEnvironment['buildLoris'] == '1' and configure.CheckHeader("Opcodes/Loris/src/loris.h") and configure.CheckHeader("fftw3.h")):
    print "CONFIGURATION DECISION: Not building Loris Python extension and Csound opcodes."
else:
    print "CONFIGURATION DECISION: Building Loris Python extension and Csound opcodes."
    # For Loris, we build only the loris Python extension module and
    # the Csound opcodes (modified for Csound 5).
    # It is assumed that you have copied all contents of the Loris
    # distribution into the csound5/Opcodes/Loris directory, e.g.
    # csound5/Opcodes/Loris/src/*, etc.
    lorisEnvironment = pluginEnvironment.Clone()
    lorisEnvironment.Append(CCFLAGS = '-DHAVE_FFTW3_H')
    if commonEnvironment['buildRelease'] == '0':
        lorisEnvironment.Append(CCFLAGS = '-DDEBUG_LORISGENS')
    if util.platform == 'win32':
        lorisEnvironment.Append(CCFLAGS = '-D_MSC_VER')
    if util.compilerGNU():
        lorisEnvironment.Prepend(LIBS = ['stdc++'])
        lorisEnvironment.Append(CCFLAGS = Split(
        '-Wno-comment -Wno-unknown-pragmas -Wno-sign-compare'))
    lorisEnvironment.Append(CPPPATH = Split(
        'Opcodes/Loris Opcodes/Loris/src ./'))
    lorisSources = glob.glob('Opcodes/Loris/src/*.[Cc]')
    if 'Opcodes/Loris/src/lorisgens.C' in lorisSources:
        lorisSources.remove('Opcodes/Loris/src/lorisgens.C')
    lorisLibrarySources = []
    for i in lorisSources:
        lorisLibrarySources += lorisEnvironment.SharedObject(i)
    lorisLibrary = lorisEnvironment.StaticLibrary(
        'lorisbase', lorisLibrarySources)
    lorisEnvironment.Prepend(LIBS = ['lorisbase', 'fftw3'])
    # The following file has been patched for Csound 5
    # and you should update it from Csound 5 CVS.
    lorisOpcodes = util.makePlugin(
        lorisEnvironment, 'loris', ['Opcodes/Loris/lorisgens5.C'])
    Depends(lorisOpcodes, lorisLibrary)
    lorisPythonEnvironment = lorisEnvironment.Clone()
    util.fixCFlagsForSwig(lorisPythonEnvironment)
    lorisPythonEnvironment.Append(CPPPATH   = pythonIncludePath)
    lorisPythonEnvironment.Append(LINKFLAGS = pythonLinkFlags)
    lorisPythonEnvironment.Append(LIBPATH   = pythonLibraryPath)
    if util.platform != 'darwin':
        lorisPythonEnvironment.Prepend(LIBS = pythonLibs)
    lorisPythonEnvironment.Append(SWIGPATH  = ['./'])
    lorisPythonEnvironment.Prepend(SWIGFLAGS = Split('''
        -module loris -c++ -includeall -verbose -outdir . -python
        -DHAVE_FFTW3_H -I./Opcodes/Loris/src -I.
    '''))
    lorisPythonWrapper = lorisPythonEnvironment.SharedObject(
        'Opcodes/Loris/scripting/loris.i')
    lorisPythonEnvironment['SHLIBPREFIX'] = ''
    lorisPythonModule = util.makePythonModule(
        lorisPythonEnvironment, 'loris', lorisPythonWrapper)
    Depends(lorisPythonModule, lorisLibrary)

# STK opcodes

if not (commonEnvironment['buildStkOpcodes'] == '1' and stkFound):
    print 'CONFIGURATION DECISION: Not building STK opcodes.'
else:
    print 'CONFIGURATION DECISION: Building STK opcodes.'
    # For the STK opcodes, the STK distribution include, src, and rawwaves
    # directories should be copied thusly:
    #   csound5/Opcodes/stk/include
    #   csound5/Opcodes/stk/src
    #   csound5/Opcodes/stk/rawwaves
    # Then, the following sources (and any other future I/O or OS dependent
    # sources) should be ignored:
    removeSources = Split('''
        Opcodes/stk/src/InetWvIn.cpp    Opcodes/stk/src/InetWvOut.cpp
        Opcodes/stk/src/Mutex.cpp       Opcodes/stk/src/RtAudio.cpp
        Opcodes/stk/src/RtMidi.cpp
        Opcodes/stk/src/RtWvIn.cpp      Opcodes/stk/src/RtWvOut.cpp
        Opcodes/stk/src/Socket.cpp      Opcodes/stk/src/TcpClient.cpp
        Opcodes/stk/src/TcpServer.cpp   Opcodes/stk/src/Thread.cpp
        Opcodes/stk/src/UdpSocket.cpp
    ''')
    stkEnvironment = pluginEnvironment.Clone()
    if util.platform == 'win32':
        stkEnvironment.Append(CCFLAGS = '-D__OS_WINDOWS__')
    elif util.platform == 'linux':
        stkEnvironment.Append(CCFLAGS = '-D__OS_LINUX__')
    elif util.platform == 'darwin':
        stkEnvironment.Append(CCFLAGS = '-D__OS_MACOSX__')
    if sys.byteorder == 'big':
        stkEnvironment.Append(CCFLAGS = '-D__BIG_ENDIAN__')
    else:
        stkEnvironment.Append(CCFLAGS = '-D__LITTLE_ENDIAN__')
    stkEnvironment.Prepend(CPPPATH = Split(
        'Opcodes/stk/include Opcodes/stk/src ./ ./../include'))
    stkSources_ = glob.glob('Opcodes/stk/src/*.cpp')
    stkSources = []
    for source in stkSources_:
        stkSources.append(source.replace('\\', '/'))
    for removeMe in removeSources:
        stkSources.remove(removeMe)
    stkLibrarySources = []
    for i in stkSources:
        stkLibrarySources += stkEnvironment.SharedObject(i)
    stkLibrary = stkEnvironment.StaticLibrary('stk_base', stkLibrarySources)
    stkEnvironment.Prepend(LIBS = ['stk_base'])
    if util.compilerGNU():
        stkEnvironment.Append(LIBS = ['stdc++'])
    elif util.platform == 'linux' or util.platform == 'darwin':
        stkEnvironment.Append(LIBS = ['pthread'])
    # This is the one that actually defines the opcodes.
    # They are straight wrappers, as simple as possible.
    stk = util.makePlugin(stkEnvironment, 'stk', ['Opcodes/stk/stkOpcodes.cpp'])
    Depends(stk, stkLibrary)

# Python opcodes

if not (pythonFound and commonEnvironment['buildPythonOpcodes'] != '0'):
    print "CONFIGURATION DECISION: Not building Python opcodes."
else:
    print "CONFIGURATION DECISION: Building Python opcodes."
    pyEnvironment = pluginEnvironment.Clone()
    if util.platform != 'darwin':
       pyEnvironment.Append(CPPPATH = pythonIncludePath)
       pyEnvironment.Append(LIBPATH = pythonLibraryPath)
    else:
       pyEnvironment.Append(
            CPPPATH = "/System/Library/Frameworks/Python.framework/Headers")

    pyEnvironment.Append(LINKFLAGS = pythonLinkFlags)
    pyEnvironment.Append(LIBS = pythonLibs)
    if util.platform == 'linux':
        pyEnvironment.Append(LIBS = ['util', 'dl', 'm'])
    elif util.platform == 'darwin':
        pyEnvironment.Append(LIBS = ['dl', 'm'])
    elif util.platform == 'win32':
        pyEnvironment['ENV']['PATH'] = os.environ['PATH']
        pyEnvironment.Append(SHLINKFLAGS = '--no-export-all-symbols')
    pythonOpcodes = util.makePlugin(
        pyEnvironment, 'py', ['Opcodes/py/pythonopcodes.c'])
    if util.platform == 'win32' and pythonLibs[0] < 'python24':
        Depends(pythonOpcodes, pythonImportLibrary)

#############################################################################
#
# Utility programs.
if buildOLPC:
  stdutilSources = Split('''
                        util/cvanal.c       util/dnoise.c
    util/envext.c
                        util/hetro.c        util/lpanal.c
                                            util/mixer.c
    util/pvanal.c       util/pvlook.c       util/scale.c
    util/sndinfo.c      util/srconv.c
    util/std_util.c
  ''')
else :
  stdutilSources = Split('''
    util/atsa.c         util/cvanal.c       util/dnoise.c
    util/envext.c       util/xtrct.c        util/het_export.c
    util/het_import.c   util/hetro.c        util/lpanal.c
    util/lpc_export.c   util/lpc_import.c   util/mixer.c
    util/pvanal.c       util/pvlook.c       util/scale.c
    util/sndinfo.c      util/srconv.c       util/pv_export.c
    util/pv_import.c
    util/std_util.c
  ''')

stdutilSources += pluginEnvironment.SharedObject('util/sdif', 'SDIF/sdif.c')
util.makePlugin(pluginEnvironment, 'stdutil', stdutilSources)

if not buildOLPC:
  if (commonEnvironment['buildUtilities'] != '0'):
    utils = [
        ['atsa',        'util/atsa_main.c'    ],
        ['cvanal',      'util/cvl_main.c'     ],
        ['dnoise',      'util/dnoise_main.c'  ],
        ['envext',      'util/env_main.c'     ],
        ['extractor',   'util/xtrc_main.c'    ],
        ['het_export',  'util/hetx_main.c'    ],
        ['het_import',  'util/heti_main.c'    ],
        ['hetro',       'util/het_main.c'     ],
        ['lpanal',      'util/lpc_main.c'     ],
        ['lpc_export',  'util/lpcx_main.c'    ],
        ['lpc_import',  'util/lpci_main.c'    ],
        ['mixer',       'util/mixer_main.c'   ],
        ['pvanal',      'util/pvc_main.c'     ],
        ['pvlook',      'util/pvl_main.c'     ],
        ['pv_export',   'util/pvx_main.c'     ],
        ['pv_import',   'util/pvi_main.c'     ],
        ['scale',       'util/scale_main.c'   ],
        ['sndinfo',     'util/sndinfo_main.c' ],
        ['srconv',      'util/srconv_main.c'  ]]
    for i in utils:
      executables.append(csoundProgramEnvironment.Program(i[0], i[1]))

if not buildOLPC:
    executables.append(csoundProgramEnvironment.Program(
        'scsort',['util1/sortex/smain.c']))
    executables.append(csoundProgramEnvironment.Program(
        'extract', ['util1/sortex/xmain.c']))
    if util.compilerGNU():
        executables.append(commonEnvironment.Program(
            'cs', ['util1/csd_util/cs.c']))
        executables.append(commonEnvironment.Program(
            'csb64enc',
            ['util1/csd_util/base64.c', 'util1/csd_util/csb64enc.c']))
        executables.append(commonEnvironment.Program(
            'makecsd',
            ['util1/csd_util/base64.c', 'util1/csd_util/makecsd.c']))
        executables.append(commonEnvironment.Program(
            'scot', ['util1/scot/scot_main.c', 'util1/scot/scot.c']))
#executables.append(csoundProgramEnvironment.Program('cscore',
#    ['util1/cscore/cscore_main.c']))
    executables.append(commonEnvironment.Program(
        'sdif2ad', ['SDIF/sdif2adsyn.c', 'SDIF/sdif.c', 'SDIF/sdif-mem.c']))

for i in executables : Depends(i, csoundLibrary)

#############################################################################
#
# Front ends.
#############################################################################


# Build CsoundAC

if not ((commonEnvironment['buildCsoundAC'] == '1') and fltkFound and boostFound and fltkFound):
    print 'CONFIGURATION DECISION: Not building CsoundAC extension module for Csound with algorithmic composition.'
else:
    print 'CONFIGURATION DECISION: Building CsoundAC extension module for Csound with algorithmic composition.'
    acEnvironment = vstEnvironment.Clone()
    headers += glob.glob('frontends/CsoundAC/*.hpp')
    acEnvironment.Prepend(CPPPATH   = ['frontends/CsoundAC', 'interfaces'])
    acEnvironment.Append(CPPPATH    = pythonIncludePath)
    acEnvironment.Append(LINKFLAGS  = pythonLinkFlags)
    acEnvironment.Append(LIBPATH    = pythonLibraryPath)
    if util.platform != 'darwin': acEnvironment.Prepend(LIBS  = pythonLibs)
    acEnvironment.Prepend(LIBS      = csndModule)
    acEnvironment.Append(SWIGFLAGS  = Split(
        '-c++ -includeall -verbose -outdir .'))
    if util.platform == 'linux':
        acEnvironment.Append(LIBS               = ['util', 'dl', 'm'])
        acEnvironment.Append(SHLINKFLAGS        = '--no-export-all-symbols')
        acEnvironment.Append(LINKFLAGS          = ['-Wl,-rpath-link,.'])
        guiProgramEnvironment.Prepend(LINKFLAGS = ['-Wl,-rpath-link,.'])
        try     : os.symlink('lib_CsoundAC.so', '_CsoundAC.so')
        except  : pass
        Clean('lib_CsoundAC.so', '_CsoundAC.so')
    elif util.platform == 'darwin':
        acEnvironment.Append(LIBS = ['dl', 'm'])
        acEnvironment.Append(SHLINKFLAGS = '--no-export-all-symbols')
        acEnvironment.Append(SHLINKFLAGS = '--add-stdcall-alias')
        acEnvironment['SHLIBSUFFIX'] = '.dylib'
    elif util.platform == 'win32':
        if  util.compilerGNU():
            acEnvironment.Prepend(LIBS = Split(
                'fltk fltk_images fltk_png fltk_jpeg fltk_z'))
        else:
            acEnvironment.Prepend(LIBS = Split(
                'fltk fltkimages fltkpng fltkjpeg fltkz'))
    for option in acEnvironment['CCFLAGS']:
        if string.find(option, '-D') == 0:
            acEnvironment.Append(SWIGFLAGS = [option])
    for option in acEnvironment['CPPFLAGS']:
        if string.find(option, '-D') == 0:
            acEnvironment.Append(SWIGFLAGS = [option])
    for option in acEnvironment['CPPPATH']:
        option = '-I' + option
        acEnvironment.Append(SWIGFLAGS = [option])
    print 'PATH =', commonEnvironment['ENV']['PATH']
    csoundAcSources = Split('''
    frontends/CsoundAC/Cell.cpp             frontends/CsoundAC/Composition.cpp
    frontends/CsoundAC/Conversions.cpp      frontends/CsoundAC/Counterpoint.cpp
    frontends/CsoundAC/CounterpointNode.cpp frontends/CsoundAC/Event.cpp
    frontends/CsoundAC/Hocket.cpp           frontends/CsoundAC/ImageToScore.cpp
    frontends/CsoundAC/Lindenmayer.cpp      frontends/CsoundAC/MCRM.cpp
    frontends/CsoundAC/Midifile.cpp         frontends/CsoundAC/MusicModel.cpp
    frontends/CsoundAC/Node.cpp             frontends/CsoundAC/Random.cpp
    frontends/CsoundAC/Rescale.cpp          frontends/CsoundAC/Score.cpp
    frontends/CsoundAC/ScoreNode.cpp        frontends/CsoundAC/Sequence.cpp
    frontends/CsoundAC/Shell.cpp            frontends/CsoundAC/Soundfile.cpp
    frontends/CsoundAC/StrangeAttractor.cpp frontends/CsoundAC/System.cpp
    frontends/CsoundAC/Voicelead.cpp        frontends/CsoundAC/VoiceleadingNode.cpp
    ''')
    swigflags = acEnvironment['SWIGFLAGS']
    acWrapperEnvironment = acEnvironment.Clone()
    util.fixCFlagsForSwig(acWrapperEnvironment)
    if commonEnvironment['dynamicCsoundLibrary'] == '1':
        csoundac = acEnvironment.Library('CsoundAC', csoundAcSources)
    else:
        csoundac = acEnvironment.Library('CsoundAC', csoundAcSources)
    libs.append(csoundac)
    Depends(csoundac, csoundInterfaces)
    Depends(csoundac, csoundLibrary)
    csoundAcPythonWrapper = acWrapperEnvironment.SharedObject(
        'frontends/CsoundAC/CsoundAC.i', SWIGFLAGS = [swigflags, '-python'])
    acWrapperEnvironment.Clean('.', 'frontends/CsoundAC/CsoundAC_wrap.h')
    if util.platform == 'darwin':
        acPythonEnvironment  = acEnvironment.Clone()
        acPythonEnvironment.Prepend(LIBS = ['CsoundAC'])
        csoundAcPythonModule = util.makePythonModule(acPythonEnvironment, 'CsoundAC',
                                                csoundAcPythonWrapper)
    else:
        acPythonEnvironment = acEnvironment.Clone()
        acPythonEnvironment.Append(LINKFLAGS    = pythonLinkFlags)
        acPythonEnvironment.Prepend(LIBPATH     = pythonLibraryPath)
        acPythonEnvironment.Prepend(LIBS        = pythonLibs)
        acPythonEnvironment.Append(CPPPATH      = pythonIncludePath)
        acPythonEnvironment.Prepend(LIBS        = ['CsoundAC'])
        csoundAcPythonModule = util.makePythonModule(
            acPythonEnvironment, 'CsoundAC', [csoundAcPythonWrapper])
        if util.platform == 'win32' and pythonLibs[0] < 'python24' and util.compilerGNU():
            Depends(csoundvstPythonModule, pythonImportLibrary)
        pythonModules.append('CsoundAC.py')
    if commonEnvironment['useDouble'] != '0' :
        counterpoint = acEnvironment.Program(
            'counterpoint', ['frontends/CsoundAC/CounterpointMain.cpp'],
            LIBS = Split('CsoundAC csnd csound64'))
    else:
        counterpoint = acEnvironment.Program(
            'counterpoint', ['frontends/CsoundAC/CounterpointMain.cpp'],
            LIBS = Split('CsoundAC csnd csound32'))

# Build CsoundVST

if not ((commonEnvironment['buildCsoundVST'] == '1') and boostFound and fltkFound):
    print 'CONFIGURATION DECISION: Not building CsoundVST plugin and standalone.'
else:
    print 'CONFIGURATION DECISION: Building CsoundVST plugin and standalone.'
    headers += glob.glob('frontends/CsoundVST/*.h')
    headers += glob.glob('frontends/CsoundVST/*.hpp')
    vstEnvironment.Prepend(CPPPATH = ['interfaces', 'frontends/CsoundVST'])
    guiProgramEnvironment.Append(CPPPATH = ['frontends/CsoundVST', 'interfaces'])
    vstEnvironment.Prepend(LIBS = ['csnd'])
    if util.platform == 'linux':
        vstEnvironment.Append(LIBS              = ['util', 'dl', 'm'])
        vstEnvironment.Append(SHLINKFLAGS       = '--no-export-all-symbols')
        vstEnvironment.Append(LINKFLAGS         = ['-Wl,-rpath-link,.'])
        guiProgramEnvironment.Prepend(LINKFLAGS = ['-Wl,-rpath-link,.'])
    elif util.platform == 'darwin':
        vstEnvironment.Append(LIBS              = ['dl', 'm'])
        # vstEnvironment.Append(CXXFLAGS = ['-fabi-version=0']) # if gcc3.2-3
        vstEnvironment.Append(SHLINKFLAGS       = '--no-export-all-symbols')
        vstEnvironment.Append(SHLINKFLAGS       = '--add-stdcall-alias')
        vstEnvironment['SHLIBSUFFIX']           = '.dylib'
    elif util.platform == 'win32':
        if util.compilerGNU():
            vstEnvironment['ENV']['PATH']       = os.environ['PATH']
            vstEnvironment.Append(SHLINKFLAGS   = Split('-Wl,--add-stdcall-alias --no-export-all-symbols'))
            vstEnvironment.Append(CCFLAGS       = ['-DNDEBUG'])
            guiProgramEnvironment.Prepend(LINKFLAGS = Split(
                '-mwindows -Wl,--enable-runtime-pseudo-reloc'))
            vstEnvironment.Prepend(LINKFLAGS =
                ['-Wl,--enable-runtime-pseudo-reloc'])
            guiProgramEnvironment.Append(LINKFLAGS  = '-mwindows')
            vstEnvironment.Append(LIBS              = Split(
                'fltk fltk_images fltk_png fltk_jpeg fltk_z'))
        else:
            vstEnvironment.Append(LIBS = Split(
                'csound64 csnd fltk fltkimages fltkpng fltkjpeg fltkz'))
    print 'PATH =', commonEnvironment['ENV']['PATH']
    csoundVstSources = Split('''
    frontends/CsoundVST/vstsdk2.4/public.sdk/source/vst2.x/audioeffect.cpp
    frontends/CsoundVST/vstsdk2.4/public.sdk/source/vst2.x/audioeffectx.cpp
    frontends/CsoundVST/vstsdk2.4/public.sdk/source/vst2.x/vstplugmain.cpp
    frontends/CsoundVST/CsoundVST.cpp       frontends/CsoundVST/CsoundVstFltk.cpp
    frontends/CsoundVST/CsoundVSTMain.cpp   frontends/CsoundVST/CsoundVstUi.cpp
    ''')
    if util.platform == 'win32':
        if util.compilerGNU():
           vstEnvironment.Append(SHLINKFLAGS = ['-module'])
           vstEnvironment['ENV']['PATH'] = os.environ['PATH']
        csoundVstSources.append('frontends/CsoundVST/_CsoundVST.def')
    csoundvst = vstEnvironment.SharedLibrary('CsoundVST', csoundVstSources)
    libs.append(csoundvst)
    Depends(csoundvst, csoundInterfaces)
    Depends(csoundvst, csoundLibrary)
    if commonEnvironment['useDouble'] != '0':
        csoundvstGui = guiProgramEnvironment.Program(
            'CsoundVSTShell', ['frontends/CsoundVST/csoundvst_main.cpp'],
            LIBS = Split('csound64 csnd CsoundVST'))
    else:
        csoundvstGui = guiProgramEnvironment.Program(
            'CsoundVSTShell', ['frontends/CsoundVST/csoundvst_main.cpp'],
            LIBS = Split('csound32 csnd CsoundVST'))
    executables.append(csoundvstGui)
    Depends(csoundvstGui, csoundvst)

# Build csoundapi~ (pd class)

# Build tclcsound

if commonEnvironment['buildTclcsound'] == '1' and tclhfound:
    print "CONFIGURATION DECISION: Building Tclcsound frontend"
    csTclEnvironment = commonEnvironment.Clone()
    if util.platform == 'darwin':
        csTclEnvironment.Append(CCFLAGS = Split('''
            -I/Library/Frameworks/Tcl.Framework/Headers
            -I/Library/Frameworks/Tk.Framework/Headers
            -I/System/Library/Frameworks/Tcl.Framework/Headers
            -I/System/Library/Frameworks/Tk.Framework/Headers
        '''))
        csTclEnvironment.Append(LINKFLAGS = Split(
            '-framework tk -framework tcl'))
    elif util.platform == 'linux':
        csTclEnvironment.Append(CPPPATH = tclIncludePath)
        csTclEnvironment.Append(LIBS = ['tcl8.4', 'tk8.4', 'dl', 'pthread'])
    elif util.platform == 'win32':
        csTclEnvironment.Append(LIBS = ['tcl84', 'tk84'])
        csTclEnvironment.Append(SHLINKFLAGS = ['-module'])
    csTclCmdObj     = csTclEnvironment.SharedObject(
        'frontends/tclcsound/commands.c')
    csTcl           = csTclEnvironment.Program(
        'cstclsh', ['frontends/tclcsound/main_tclsh.c', csTclCmdObj])
    csTk            = csTclEnvironment.Program(
        'cswish', ['frontends/tclcsound/main_wish.c', csTclCmdObj])
    Tclcsoundlib    = csTclEnvironment.SharedLibrary(
        'tclcsound', ['frontends/tclcsound/tclcsound.c', csTclCmdObj],
        SHLIBPREFIX = '')
    if util.platform == 'darwin':
        tmp = "/Developer/Tools/Rez -i APPL -o cswish frontends/tclcsound/cswish.r"
        csTclEnvironment.Command('cswish_resources', 'cswish', tmp)
        if commonEnvironment['dynamicCsoundLibrary'] == '1':
            tmp  = 'mkdir /Library/Frameworks/CsoundLib.framework/Resources/TclTk'
            tmp += '; cp -R tclcsound.dylib /Library/Frameworks/CsoundLib.framework/Resources/TclTk/'
            csTclEnvironment.Command('tclcsound_install', 'tclcsound.dylib',
                                    tmp)
    Depends(csTcl, csoundLibrary)
    Depends(csTk, csoundLibrary)
    Depends(Tclcsoundlib, csoundLibrary)
    executables.append(csTcl)
    executables.append(csTk)
    libs.append(Tclcsoundlib)
    try     : os.mkdir('tclcsound', 0755)
    except  : pass
#    if util.platform == 'darwin':
#      csTclEnvironment.Command('tclcsound/pkgIndex.tcl', 'tclcsound.dylib','cp tclcsound.dylib tclcsound; tclsh pkgbuild.tcl')
#    elif util.platform == 'linux':
#      csTclEnvironment.Command('tclcsound/pkgIndex.tcl', 'tclcsound.so','cp tclcsound.so tclcsound; tclsh pkgbuild.tcl')
#    elif  util.platform == 'win32':
#      csTclEnvironment.Command('tclcsound/tclcsound.dll', 'tclcsound.dll','cp tclcsound.dll tclcsound')
#      csTclEnvironment.Command('tclcsound/pkgIndex.tcl', 'tclcsound/tclcsound.dll','tclsh84 pkgbuild.tcl')

else:
    print "CONFIGURATION DECISION: Not building Tclcsound"


if (commonEnvironment['generateTags']=='0') or (util.platform != 'darwin' and util.platform != 'linux'):
    print "CONFIGURATION DECISION: Not calling TAGS"
else:
    print "CONFIGURATION DECISION: Calling TAGS"
    allSources = string.join(glob.glob('*/*.h*'))
    allSources = allSources + ' ' + string.join(glob.glob('*/*.c*'))
    allSources = allSources + ' ' + string.join(glob.glob('*/*.hpp'))
    allSources = allSources + ' ' + string.join(glob.glob('*/*/*.c*'))
    allSources = allSources + ' ' + string.join(glob.glob('*/*/*.h'))
    allSources = allSources + ' ' + string.join(glob.glob('*/*/*.hpp'))
    tags = commonEnvironment.Command('TAGS', Split(allSources), 'etags $SOURCES')
    Depends(tags, csoundLibrary)

if commonEnvironment['useGettext'] == '1':
    csound5GettextEnvironment = csoundProgramEnvironment.Clone()
    util.gettextTarget(csound5GettextEnvironment, 'french', 'fr')
    util.gettextTarget(csound5GettextEnvironment, 'american', 'en_US')
    util.gettextTarget(csound5GettextEnvironment, 'csound', 'en_GB')
    util.gettextTarget(csound5GettextEnvironment, 'es_CO', 'es_CO')
    ##  The following are incomplete
    util.gettextTarget(csound5GettextEnvironment, 'german', 'de')
    ## italian is not in the repository (VL 28-01-08), will not build
    #gettextTarget(csound5GettextEnvironment, 'italian', 'it')
    util.gettextTarget(csound5GettextEnvironment, 'romanian', 'ro')

# INSTALL OPTIONS

PREFIX = commonEnvironment['prefix']

BIN_DIR = PREFIX + "/bin"
INCLUDE_DIR = PREFIX + "/include/csound"

if (commonEnvironment['Lib64'] == '1'):
    LIB_DIR = PREFIX + "/lib64"
    PYTHON_DIR = '%s/lib64' % sys.prefix
else:
    LIB_DIR = PREFIX + "/lib"
    PYTHON_DIR = '%s/lib' % sys.prefix

PYTHON_DIR += '/python%s/site-packages' % commonEnvironment['pythonVersion']

for i in sys.path:
    if i[:sys.prefix.__len__()] == sys.prefix and i[-13:] == 'site-packages':
        PYTHON_DIR = i

if commonEnvironment['useDouble'] == '0':
    PLUGIN_DIR = LIB_DIR + "/csound/plugins"
else:
    PLUGIN_DIR = LIB_DIR + "/csound/plugins64"

if commonEnvironment['install'] == '1':
    installExecutables = Alias('install-executables',
        Install(BIN_DIR, executables))
    installOpcodes = Alias('install-opcodes',
        Install(PLUGIN_DIR, pluginLibraries))
    installHeaders = Alias('install-headers',
        Install(INCLUDE_DIR, headers))
    installLibs = Alias('install-libs',
        Install(LIB_DIR, libs))
    installPythonModules = Alias('install-py',
        Install(PYTHON_DIR, pythonModules))
    Alias('install', [installExecutables, installOpcodes, installLibs, installHeaders, installPythonModules])


###Code to create pkconfig files
#env = Environment(tools=['default', 'scanreplace'], toolpath=['tools'])
#env['prefix'] = '/usr/local'
#env.ScanReplace('csound5.pc.in')

Export( "commonEnvironment", "commandOptions", "util" )
Export( "configure" )
SConscript('frontends/SConscript')
SConscript('Opcodes/SConscript')
SConscript('InOut/SConscript')


if util.platform == 'linux' and commonEnvironment['useFLTK'] == '1':
    print "CONFIGURATION DECISION: Adding resource fork for csound"
    util.addOSXResourceFork(commonEnvironment, 'csound', '')

