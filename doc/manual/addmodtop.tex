\begin{comment}
\documentclass[10pt]{article}
\usepackage{fullpage, graphicx, url}
\setlength{\parskip}{1ex}
\setlength{\parindent}{0ex}
\title{Adding your own Cmodules to Csound}
\begin{document}


\begin{tabular}{ccc}
The Alternative Csound Reference Manual & & \\
Previous & &Next

\end{tabular}

%\hline 
\end{comment}
\section{Adding your own Cmodules to Csound}


  If the existing Csound generators do not suit your needs, you can write your own modules in C and add them to the run-time system. When you invoke Csound on an orchestra and score file, the orchestra is first read by a table-driven translator 'otran' and the instrument blocks converted to coded templates ready for loading into memory by 'oload' on request by the score reader. To use your own C-modules within a standard orchestra you need only add an entry in otran's table and relink Csound with your own code. 


  The translator, loader, and run-time monitor will treat your module just like any other provided you follow some conventions. You need a structure defining the inputs, outputs and workspace, plus some initialization code and some perf-time code. Let's put an example of these in two new files, newgen.h and newgen.c: 


 
\begin{lstlisting}
/* newgen.h  -  define a structure */
typedef struct
{
  OPDS h;  /* required header */
  float *result, *istrt, *incr, *itime, *icontin; /* addr outarg, inargs */
  float curval, vincr;  /* private dataspace */
  long countdown;  /* ditto */
} RMP;


/* newgen.c -  init and perf code */
#include "cs.h"
#include "newgen.h"

void rampset (RMP * p)  /* at note initialization: */
{
  if (*p - icontin == 0.)
    p - curval = *p - istrt;  /* optionally get new start value */
  p - vincr = *p - incr / esr;  /* set s-rate increment per sec. */
  p - countdown = *p - itime * esr;  /* counter for itime seconds */
}
 
void ramp (RMP * p)  /* during note performance: */
{
  float *rsltp = p - result;  /* init an output array pointer */
  int nn = ksmps;  /* array size from orchestra */
  do
    {
      *rsltp++ = p - curval;  /* copy current value to output */
      if (--p - countdown = 0)  /* for the first itime seconds, */
        p - curval += p - vincr;  /* ramp the value */
    }
  while (--nn);
}                         
      
\end{lstlisting}


 


  Now we add this module to the translator table entry.c, under the opcode name rampt: 


 
\begin{lstlisting}
#include "newgen.h"
  
void rampset(), ramp();
  
/*   opcode    dspace  thread    outarg    inargs      isub       ksub     asub    */
  
{ "rampt",  S(RMP),  5,        "a",      "iiio",     rampset,   NULL,    ramp  },
      
\end{lstlisting}


 


  Finally we relink Csound to include the new module. If your Csound installation has created a libcsound.a, you can do this by typing 


 
\begin{lstlisting}
cc -o mycsound newgen.c entry.c -lcsound -lX11 -lm
(X11 if included at installation)
      
\end{lstlisting}


 


  Else copy *.c, *.h and Makefile from the Csound sources, add newgen.o to the Makefile list OBJS, add newgen.h as a dependency for entry.o, and a new dependency 'newgen.o: newgen.h', then run 'make CSound'. If your host is a Macintosh, simply add newgen.h and newgen.c to one of the segments in the Csound Project, and invoke the C compiler. 


  The above actions have added a new generator to the Csound language. It is an audio-rate linear ramp function which modifies an input value at a user-defined slope for some period. A ramp can optionally continue from the previous note's last value. The Csound manual entry would look like: 


 
\begin{lstlisting}
ar rampt istart, islope, itime [, icontin]
      
\end{lstlisting}


 


 \emph{istart}
 -- beginning value of an audio-rate linear ramp. Optionally overridden by a continue flag. 


 \emph{islope}
 -- slope of ramp, expressed as the y-interval change per second. 


 \emph{itime}
 -- ramp time in seconds, after which the value is held for the remainder of the note. 


 \emph{icontin}
 (optional) -- continue flag. If zero, ramping will proceed from input \emph{istart}
 . If non-zero, ramping will proceed from the last value of the previous note. The default value is zero. 


  The file \emph{newgen.h}
 includes a one-line list of output and input parameters. These are the ports through which the new generator will communicate with the other generators in an instrument. Communication is by \emph{address}
, not \emph{value}
, and this is a list of pointers to floats. There are no restrictions on names, but the input-output argument types are further defined by character strings in entry.c (inargs, outargs). Inarg types are commonly \emph{x}
, \emph{a}
, \emph{k}
, and \emph{i}
, in the normal Csound manual conventions; also available are o (optional, defaulting to 0), p (optional, defaulting to 1). Outarg types include \emph{a}
, \emph{k}
, \emph{i}
 and \emph{s}
 (asig or ksig). It is important that all listed argument names be assigned a corresponding argument type in entry.c. Also, i-type args are valid only at initialization time, and other-type args are available only at perf time. Subsequent lines in the RMP structure declare the work space needed to keep the code re-entrant. These enable the module to be used multiple times in multiple instrument copies while preserving all data. 


  The file \emph{newgen.c}
 contains two subroutines, each called with a pointer to the uniquely allocated RMP structure and its data. The subroutines can be of three types: note initialization, k-rate signal generation, a-rate signal generation. A module normally requires two of these initialization, and either k-rate or a-rate subroutines which become inserted in various threaded lists of runnable tasks when an instrument is activated. The thread-types appear in entry.c in two forms: \emph{isub}
, \emph{ksub}
 and \emph{asub}
 names; and a threading index which is the sum of isub=1, ksub=2, asub=4. The code itself may reference global variables defined in \emph{cs.h}
 and \emph{oload.c}
, the most useful of which are: 


 
\begin{lstlisting}
  extern  OPARMS  O ;          float   esr
      user-defined sampling rate   float   ekr
      user-defined control rate    float   ensmps
      user-defined ksmps           int     ksmps
      user-defined ksmps           int     nchnls
      user-defined nchnls          int     O.odebug
      command-line -v flag         int     O.msglevel
      command-line -m level        float   pi, twopi    obvious
      constants                    float   tpidsr    twopi / esr float
      sstrcod                      special code for string arguments
      
\end{lstlisting}


 
\section{Function tables}


  To access stored function tables, special help is available. The newly defined structure should include a pointer 


 
\begin{lstlisting}
FUNC        *ftp;
        
\end{lstlisting}


 


  initialized by the statement 


 
\begin{lstlisting}
ftp = ftpfind(p-ifuncno);
        
\end{lstlisting}


 


  where float *ifuncno is an i-type input argument containing the ftable number. The stored table is then at ftp-ftable, and other data such as length, phase masks, cps-to-incr converters, are also accessed from this pointer. See the FUNC structure in cs.h, the ftfind() code in fgens.c, and the code for oscset() and koscil() in opcodes2.c. 
%\hline 


\begin{comment}
\begin{tabular}{lcr}
Previous &Home &Next \\
Compiling a Cscore Program &Up &Additional Space

\end{tabular}


\end{document}
\end{comment}
