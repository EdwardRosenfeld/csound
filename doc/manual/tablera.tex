\begin{comment}
\documentclass[10pt]{article}
\usepackage{fullpage, graphicx, url}
\setlength{\parskip}{1ex}
\setlength{\parindent}{0ex}
\title{tablera}
\begin{document}


\begin{tabular}{ccc}
The Alternative Csound Reference Manual & & \\
Previous & &Next

\end{tabular}

%\hline 
\end{comment}
\section{tablera}
tablera --  Reads tables in sequential locations. \subsection*{Description}


  These opcodes read and write tables in sequential locations to and from an a-rate variable. Some thought is required before using them. They have at least two major, and quite different, applications which are discussed below. 
\subsection*{Syntax}


 ar \textbf{tablera}
 kfn, kstart, koff
\subsection*{Performance}


 \emph{ar}
 -- a-rate destination for reading \emph{ksmps}
 values from a table. 


 \emph{kfn}
 -- i- or k-rate number of the table to read or write. 


 \emph{kstart}
 -- Where in table to read or write. 


 \emph{koff}
 -- i- or k-rate offset into table. Range unlimited - see explanation at end of this section. 


  In one application, these are intended to be used in pairs, or with several \emph{tablera}
 opcodes before a \emph{tablewa}
 -- all sharing the same \emph{kstart}
 variable. 


  These read from and write to sequential locations in a table at audio rates, with \emph{ksmps}
 floats being written and read each cycle. 


 \emph{tablera}
 starts reading from location \emph{kstart}
. \emph{tablewa}
 starts writing to location \emph{kstart}
, and then writes to \emph{kstart}
 with the number of the location one more than the one it last wrote. (Note that for \emph{tablewa}
, \emph{kstart}
 is both an input and output variable.) If the writing index reaches the end of the table, then no further writing occurs and zero is written to \emph{kstart}
. 


  For instance, if the table's length was 16 (locations 0 to 15), and \emph{ksmps}
 was 5. Then the following steps would occur with repetitive runs of the \emph{tablewa}
 opcode, assuming that \emph{kstart}
 started at 0. 


 


\begin{tabular}{|c|c|c|c|}
%\hline 
Run NumberInitial kstartFinal kstartLocations Written & & & \\
 %\hline 
1050 1 2 3 4 &25105 6 7 8 9 &3101510 11 12 13 14 &415015 \\
 %\hline 

\end{tabular}



 


  This is to facilitate processing table data using standard a-rate orchestra code between the \emph{tablera}
 and \emph{tablewa}
 opcodes. They allow all Csound k-rate operators to be used (with caution) on a-rate variables - something that would only be possible otherwise by \emph{ksmps}
 = 1, downsamp and upsamp. 


 


\begin{tabular}{cc}
Caution &\textbf{Several cautions}
 \\
  &

 


 
\begin{itemize}
\item 

  The k-rate code in the processing loop is really running at a-rate, so time dependent functions like \emph{port}
 and \emph{oscil}
 work faster than normal - their code is expecting to be running at k-rate. 

\item 

  This system will produce undesirable results unless the \emph{ksmps}
 fits within the table length. For instance a table of length 16 will accommodate 1 to 16 samples, so this example will work with \emph{ksmps}
 = 1 to 16. 


\end{itemize}


\end{tabular}



  Both these opcodes generate an error and deactivate the instrument if a table with length $<$ \emph{ksmps}
 is selected. Likewise an error occurs if \emph{kstart}
 is below 0 or greater than the highest entry in the table - if \emph{kstart}
 = table length. 


 


 
\begin{itemize}
\item 

 \emph{kstart}
 is intended to contain integer values between 0 and (table length - 1). Fractional values above this should not affect operation but do not achieve anything useful. 

\item 

  These opcodes are not interpolating, and the \emph{kstart}
 and \emph{koff}
 parameters always have a range of 0 to (table length - 1) - not 0 to 1 as is available in other table read/write opcodes. \emph{koff}
 can be outside this range but it is wrapped around by the final AND operation. 

\item 

  These opcodes are permanently in wrap mode. When \emph{koff}
 is 0, no wrapping needs to occur, since the \emph{kstart}
++ index will always be within the table's normal range. \emph{koff}
 not equal to 0 can lead to wrapping. 

\item 

  The offset does not affect the number of read/write cycles performed, or the value written to \emph{kstart}
 by \emph{tablewa}
. 

\item 

  These opcodes cannot read or write the guardpoint. Use \emph{tablegpw}
 to write the guardpoint after manipulations have been done with \emph{tablewa}
. 


\end{itemize}
\subsection*{Examples}


 


 
\begin{lstlisting}
kstart   =       0         
                           
lab1:
  atemp  \emph{tablera}
 ktabsource, kstart, 0  ; Read 5 values from table into an
         ; a-rate variable.  
                           
  atemp  =       log(atemp)  ; Process the values using a-rate
         ; code.    

  kstart \emph{tablewa}
 ktabdest, atemp, 0   ; Write it back to the table
         
if ktemp  0 goto lab1      ; Loop until all table locations
         ; have been processed.
       
\end{lstlisting}


 


  The above example shows a processing loop, which runs every k-cycle, reading each location in the table \emph{ktabsource}
, and writing the log of those values into the same locations of table \emph{ktabdest}
. 


  This enables whole tables, parts of tables (with offsets and different control loops) and data from several tables at once to be manipulated with a-rate code and written back to another (or to the same) table. This is a bit of a fudge, but it is faster than doing it with k-rate table read and write code. 


  Another application is: 


 


 
\begin{lstlisting}
kzero = 0                    
kloop = 0                    
                                 
kzero \emph{tablewa}
 23, asignal, 0  ; ksmps a-rate samples written
       ; into locations 0 to (ksmps -1) of table 23.
                                
lab1: ktemp \emph{table}
 kloop, 23  ; Start a loop which runs ksmps times, 
       ; in which each cycle processes one of 
 [ Some code to manipulate ]  ; table 23's values with k-rate orchestra
 [ the value of ktemp. ]  ; code.
                                 
 \emph{tablew}
 ktemp, kloop, 23  ; Write the processed value to the table.
                                
kloop = kloop + 1      ; Increment the kloop, which is both the
       ; pointer into the table and the loop 
if kloop < ksmps goto lab1  ; counter. Keep looping until all values
       ; in the table have been processed.
                                
asignal   \emph{tablera}
 23, 0, 0  ; Copy the table contents back
       ; to an a-rate variable.
       
\end{lstlisting}


 


 \emph{koff}
 -- This is an offset which is added to the sum of \emph{kstart}
 and the internal index variable which steps through the table. The result is then ANDed with the lengthmask (000 0111 for a table of length 8 - or 9 with guardpoint) and that final index is used to read or write to the table. \emph{koff}
 can be any value. It is converted into a long using the ANSI floor() function so that -4.3 becomes -5. This is what we would want when using offsets which range above and below zero. 


  Ideally this would be an optional variable, defaulting to 0, however with the existing Csound orchestra read code, such default parameters must be init time only. We want k-rate here, so we cannot have a default. 
%\hline 


\begin{comment}
\begin{tabular}{lcr}
Previous &Home &Next \\
tableng &Up &tableseg

\end{tabular}


\end{document}
\end{comment}
