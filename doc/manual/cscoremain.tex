\begin{comment}
\documentclass[10pt]{article}
\usepackage{fullpage, graphicx, url}
\setlength{\parskip}{1ex}
\setlength{\parindent}{0ex}
\title{Writing a Main Program}
\begin{document}


\begin{tabular}{ccc}
The Alternative Csound Reference Manual & & \\
Previous &Cscore &Next

\end{tabular}

%\hline 
\end{comment}
\section{Writing a Main Program}


  The general format for a control program is: 


 
\begin{lstlisting}
#include  "cscore.h" 
cscore() 
{ 
 /*  VARIABLE DECLARATIONS  */ 
 /*  PROGRAM BODY  */ 
}
      
\end{lstlisting}


 


  The include statement will define the event and list structures for the program. The following C program will read from a\emph{ standard numeric score,}
 up to (but not including) the first \emph{s}
 or \emph{e statement}
, then write that data (unaltered) as output. 


 


 
\begin{lstlisting}
#include  "cscore.h" 
cscore() 
{ 
     EVLIST *a;       /* a is allowed to point to an event list */ 
     a = lget();      /* read events in, return the list pointer */ 
     lput(a);         /* write these events out (unchanged) */ 
     putstr("e");     /* write the string e to output */ 
}
      
\end{lstlisting}


 


  After execution of \emph{lget()}
, the variable a points to a list of event addresses, each of which points to a stored event. We have used that same pointer to enable another list function (\emph{lput}
) to access and write out all of the events that were read. If we now define another symbol \emph{e}
 to be an event pointer, then the statement 


 
\begin{lstlisting}
e = a-e[4];
      
\end{lstlisting}


 
 will set it to the contents of the 4th slot in the \emph{evlist}
 structure. The contents is a pointer to an event, which is itself comprised of an \emph{array }
of parameter field values. Thus the term \emph{e-p[5]}
 will mean the value of parameter field 5 of the 4th event in the\emph{ evlist}
 denoted by \emph{a}
. The program below will multiply the value of that \emph{pfield }
by 2 before writing it out. 

 
\begin{lstlisting}
#include  "cscore.h" 
cscore() 
{ 
     EVENT  *e;       /* a pointer to an event   */ 
     EVLIST *a; 
     a = lget();      /* read a score as a list of events */ 
     e = a-e[4];     /* point to event 4 in event list a  */ 
     e-p[5] *= 2;    /* find pfield 5, multiply its value by 2 */ 
     lput(a);         /* write out the list of events  */ 
     putstr("e");     /* add a "score end" statement */ 
}
      
\end{lstlisting}


 


  Now consider the following score, in which \emph{p[5]}
 contains frequency in Hz. 


 
\begin{lstlisting}
f 1 0 257 10 1 
f 2 0 257 7 0 300 1 212 .8 
i 1 1 3 0 440 10000 
i 1 4 3 0 256 10000 
i 1 7 3 0 880 10000 
e
      
\end{lstlisting}


 


  If this score were given to the preceding main program, the resulting output would look like this: 


 
\begin{lstlisting}
f 1 0 257 10 1 
f 2 0 257 7 0 300 1 212 .8 
i 1 1 3 0 440 10000 
i 1 4 3 0 512 10000        ; p[5] has become 512 instead of 256. 
i 1 7 3 0 880 10000 
e
      
\end{lstlisting}


 


  Note that the 4th event is in fact the second note of the score. So far we have not distinguished between notes and function table setup in a numeric score. Both can be classed as events. Also note that our 4th event has been stored in \emph{e[4]}
 of the structure. For compatibility with Csound \emph{pfield}
 notation, we will ignore \emph{p[0]}
 and \emph{e[0]}
 of the event and list structures, storing \emph{p1}
 in \emph{p[1]}
, event 1 in \emph{e[1]}
, etc. The\emph{ Cscore }
functions all adopt this convention. 


  As an extension to the above, we could decide to use \emph{a}
 and \emph{e}
 to examine each of the events in the list. Note that e has not preserved the numeral 4, but the contents of that slot. To inspect \emph{p5}
 of the previous listed event we need only redefine e with the assignment 


 
\begin{lstlisting}
e = a-e[3];
      
\end{lstlisting}


 


  More generally, if we declare a new variable \emph{f }
to be a pointer to a pointer to an event, the statement 


 
\begin{lstlisting}
f = &a-e[4];
      
\end{lstlisting}


 
 will set \emph{f}
 to the address of the fourth event in the event list \emph{a,}
 and \emph{*f}
 will signify the contents of the slot, namely the event pointer itself. The expression 

 
\begin{lstlisting}
(*f)-p[5],
      
\end{lstlisting}


 
 like \emph{e-p[5]}
, signifies the fifth pfield of the selected event. However, we can advance to the next slot in the \emph{evlist}
 by advancing the pointer \emph{f}
. In C this is denoted by \emph{f++}
. 

  In the following program we will use the same input score. This time we will separate the \emph{ftable}
 statements from the \emph{note }
statements. We will next write the three note-events stored in the list\emph{ a,}
 then create a second score section consisting of the original pitch set and a transposed version of itself. This will bring about an octave doubling. 


  By pointing the variable\emph{ f}
 to the first note-event and incrementing \emph{f}
 inside a while block which iterates\emph{ n }
times (the number of events in the list), one statement can be made to act upon the same \emph{pfield}
 of each successive event. 


 
\begin{lstlisting}
#include  "cscore.h"
 cscore()
 {
      EVENT *e,**f;            /* declarations. see pp.8-9 in the */ 
      EVLIST *a,*b;            /* C language programming manual */ 
      int n; 
      a = lget();              /* read score into event list "a" */ 
      b = lsepf(a);            /* separate f statements */ 
      lput(b);                 /* write f statements out to score */ 
      lrelev(b);               /* and release the spaces used */ 
      e = defev("t 0 120");    /* define event for tempo statement */ 
      putev(e);                /* write tempo statement to score */ 
      lput(a);                 /* write the notes */ 
      putstr("s");             /* section end */ 
      putev(e);                /* write tempo statement again */ 
      b = lcopyev(a);          /* make a copy of the notes in "a" */ 
      n = b-nevents;          /* and get the number present */ 
      f = &a-e[1]; 
      while (n--)              /* iterate the following line n times: */ 
          (*f++)-p[5] *= .5;  /*   transpose pitch down one octave */ 
      a = lcat(b,a);           /* now add these notes to original pitches */ 
      lput(a); 
      putstr("e");
     }
      
\end{lstlisting}


 
 The output of this program is: 

 
\begin{lstlisting}
f 1 0 257 10 1 
f 2 0 257 7 0 300 1 212 .8 
t 0 120 
i 1 1 3 0 440 10000 
i 1 4 3 0 256 10000 
i 1 7 3 0 880 10000 
s 
t 0 120 
i 1 1 3 0 440 10000 
i 1 4 3 0 256 10000 
i 1 7 3 0 880 10000 
i 1 1 3 0 220 10000 
i 1 4 3 0 128 10000 
i 1 7 3 0 440 10000 
e
      
\end{lstlisting}


 


  Next we extend the above program by using the while statement to look at \emph{p[5]}
 and \emph{p[6]}
. In the original score \emph{p[6]}
 denotes amplitude. To create a diminuendo in the added lower octave, which is independent from the original set of notes, a variable called \emph{dim}
 will be used. 


 
\begin{lstlisting}
#include "cscore.h" 
cscore() 
{ 
  EVENT *e,**f; 
  EVLIST *a,*b; 
  int n, dim;                /* declare two integer variables   */ 
  a = lget(); 
  b = lsepf(a); 
  lput(b); 
  lrelev(b); 
  e = defev("t 0 120"); 
  putev(e); 
  lput(a); 
  putstr("s"); 
  putev(e);                  /* write out another tempo statement */ 
  b = lcopyev(a); 
  n = b-nevents; 
  dim = 0;                   /* initialize dim to 0 */ 
  f = &a-e[1]; 
  while (n--){ 
       (*f)-p[6] -= dim;    /* subtract current value of dim */ 
       (*f++)-p[5] *= .5;   /* transpose, move f to next event */ 
       dim += 2000;          /* increase dim for each note */ 
  } 
  a = lcat(b,a); 
  lput(a); 
  putstr("e");
} 
      
\end{lstlisting}


 


  The increment of \emph{f}
 in the above programs has depended on certain precedence rules of C. Although this keeps the code tight, the practice can be dangerous for beginners. Incrementing may alternately be written as a separate statement to make it more clear. 


 
\begin{lstlisting}
while (n--){ 
     (*f)-p[6] -= dim; 
     (*f)-p[5] *= .5; 
     dim += 2000; 
     f++; 
}
      
\end{lstlisting}


 


  Using the same input score again, the output from this program is: 


 
\begin{lstlisting}
f 1 0 257 10 1 
f 2 0 257 7 0 300 1 212 .8 
t 0 120 
i 1 1 3 0 440 10000 
i 1 4 3 0 256 10000 
i 1 7 3 0 880 10000 
s 
t 0 120 
i 1 1 3 0 440 10000     ; Three original notes at 
i 1 4 3 0 256 10000     ; beats 1,4 and 7 with no dim. 
i 1 7 3 0 880 10000 
i 1 1 3 0 220 10000     ; three notes transposed down one octave 
i 1 4 3 0 128 8000      ; also at beats 1,4 and 7 with dim. 
i 1 7 3 0 440 6000 
e
      
\end{lstlisting}


 


  In the following program the same three-note sequence will be repeated at various time intervals. The starting time of each group is determined by the values of the \emph{array}
 cue. This time the \emph{dim}
 will occur for each group of notes rather than each note. Note the position of the statement which increments the variable \emph{dim}
 outside the inner while block. 


 
\begin{lstlisting}
#include  "cscore.h" 
int cue[3]={0,10,17};              /* declare an array of 3 integers */ 
cscore() 
{
     EVENT *e, **f;
     EVLIST *a, *b;
     int n, dim, cuecount, holdn;  /* declare new variables */ 
     a = lget(); 
     b = lsepf(a); 
     lput(b); 
     lrelev(b); 
     e = defev("t 0 120"); 
     putev(e); 
     n = a-nevents; 
     holdn = n;                    /* hold the value of "n" to reset below */ 
     cuecount = 0;                 /* initialize cuecount to "0" */ 
     dim = 0; 
     while (cuecount <= 2) {       /* count 3 iterations of inner "while" */ 
          f = &a-e[1];            /* reset pointer to first event of list "a" */ 
          n = holdn;               /* reset value of "n" to original note count */ 
          while (n--) { 
              (*f)-p[6] -= dim; 
              (*f)-p[2] += cue[cuecount];   /* add values of cue */ 
              f++; 
          } 
          printf("; diagnostic:  cue = %d\n", cue[cuecount]); 
          cuecount++; 
          dim += 2000; 
           lput(a); 
     } 
     putstr("e"); 
}
      
\end{lstlisting}


 


  Here the inner while block looks at the events of list a (the notes) and the outer while block looks at each repetition of the\emph{ events}
 of list a (the pitch group repetitions). This program also demonstrates a useful trouble-shooting device with the \emph{printf}
 function. The \emph{semi-colon}
 is first in the character string to produce a comment statement in the resulting score file. In this case the value of cue is being printed in the output to insure that the program is taking the proper \emph{array}
 member at the proper time. When output data is wrong or error messages are encountered, the \emph{printf}
 function can help to pinpoint the problem. 


  Using the identical input file, the C program above will generate: 


 
\begin{lstlisting}
f 1 0 257 10 1 
f 2 0 257 7 0 300 1 212 .8 
t 0 120 
; diagnostic:  cue = 0 
i 1 1 3 0 440 10000 
i 1 4 3 0 256 10000 
i 1 7 3 0 880 10000 
; diagnostic:  cue = 10 
i 1 11 3 0 440 8000 
i 1 14 3 0 256 8000 
i 1 17 3 0 880 8000 
; diagnostic:  cue = 17 
i 1 28 3 0 440 4000 
i 1 31 3 0 256 4000 
i 1 34 3 0 880 4000 
e;
      
\end{lstlisting}


 
%\hline 


\begin{comment}
\begin{tabular}{lcr}
Previous &Home &Next \\
Cscore &Up &More Advanced Examples

\end{tabular}


\end{document}
\end{comment}
